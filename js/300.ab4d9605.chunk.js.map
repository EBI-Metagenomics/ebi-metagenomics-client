{"version":3,"file":"js/300.ab4d9605.chunk.js","mappings":"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","sources":["webpack://mgportalv2/./node_modules/dexie-react-hooks/dist/dexie-react-hooks.js","webpack://mgportalv2/./node_modules/dexie/dist/modern/dexie.mjs","webpack://mgportalv2/./node_modules/lodash-es/now.js","webpack://mgportalv2/./node_modules/lodash-es/debounce.js","webpack://mgportalv2/./node_modules/lodash-es/findIndex.js","webpack://mgportalv2/./node_modules/lodash-es/find.js","webpack://mgportalv2/./node_modules/lodash-es/_createFind.js","webpack://mgportalv2/./node_modules/lodash-es/_baseFindIndex.js","webpack://mgportalv2/./node_modules/lodash-es/_createRound.js","webpack://mgportalv2/./node_modules/lodash-es/round.js","webpack://mgportalv2/./node_modules/lodash-es/toFinite.js","webpack://mgportalv2/./node_modules/lodash-es/toInteger.js","webpack://mgportalv2/./node_modules/lodash-es/_trimmedEndIndex.js","webpack://mgportalv2/./node_modules/lodash-es/_baseTrim.js","webpack://mgportalv2/./node_modules/lodash-es/toNumber.js"],"sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('dexie'), require('react')) :\n    typeof define === 'function' && define.amd ? define(['exports', 'dexie', 'react'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.DexieReactHooks = {}, global.Dexie, global.React));\n}(this, (function (exports, dexie, React) { 'use strict';\n\n    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\n    var React__default = /*#__PURE__*/_interopDefaultLegacy(React);\n\n    function useObservable(observableFactory, arg2, arg3) {\n        // Resolve vars from overloading variants of this function:\n        var deps;\n        var defaultResult;\n        if (typeof observableFactory === 'function') {\n            deps = arg2 || [];\n            defaultResult = arg3;\n        }\n        else {\n            deps = [];\n            defaultResult = arg2;\n        }\n        // Create a ref that keeps the state we need\n        var monitor = React__default['default'].useRef({\n            hasResult: false,\n            result: defaultResult,\n            error: null,\n        });\n        // We control when component should rerender. Make triggerUpdate\n        // as examplified on React's docs at:\n        // https://reactjs.org/docs/hooks-faq.html#is-there-something-like-forceupdate\n        var _a = React__default['default'].useReducer(function (x) { return x + 1; }, 0); _a[0]; var triggerUpdate = _a[1];\n        // Memoize the observable based on deps\n        var observable = React__default['default'].useMemo(function () {\n            // Make it remember previous subscription's default value when\n            // resubscribing.\n            var observable = typeof observableFactory === 'function'\n                ? observableFactory()\n                : observableFactory;\n            if (!observable || typeof observable.subscribe !== 'function') {\n                if (observableFactory === observable) {\n                    throw new TypeError(\"Given argument to useObservable() was neither a valid observable nor a function.\");\n                }\n                else {\n                    throw new TypeError(\"Observable factory given to useObservable() did not return a valid observable.\");\n                }\n            }\n            if (!monitor.current.hasResult) {\n                // Optimize for BehaviorSubject and other observables implementing getValue():\n                if (typeof observable.getValue === 'function') {\n                    monitor.current.result = observable.getValue();\n                    monitor.current.hasResult = true;\n                }\n                else {\n                    // Find out if the observable has a current value: try get it by subscribing and\n                    // unsubscribing synchronously\n                    var subscription = observable.subscribe(function (val) {\n                        monitor.current.result = val;\n                        monitor.current.hasResult = true;\n                    });\n                    // Unsubscribe directly. We only needed any synchronous value if it was possible.\n                    if (typeof subscription === 'function') {\n                        subscription();\n                    }\n                    else {\n                        subscription.unsubscribe();\n                    }\n                }\n            }\n            return observable;\n        }, deps);\n        // Integrate with react devtools:\n        React__default['default'].useDebugValue(monitor.current.result);\n        // Subscribe to the observable\n        React__default['default'].useEffect(function () {\n            var subscription = observable.subscribe(function (val) {\n                var current = monitor.current;\n                if (current.error !== null || current.result !== val) {\n                    current.error = null;\n                    current.result = val;\n                    current.hasResult = true;\n                    triggerUpdate();\n                }\n            }, function (err) {\n                var current = monitor.current;\n                if (current.error !== err) {\n                    current.error = err;\n                    triggerUpdate();\n                }\n            });\n            return typeof subscription === 'function'\n                ? subscription // Support observables that return unsubscribe directly\n                : subscription.unsubscribe.bind(subscription);\n        }, deps);\n        // Throw if observable has emitted error so that\n        // an ErrorBoundrary can catch it\n        if (monitor.current.error)\n            throw monitor.current.error;\n        // Return the current result\n        return monitor.current.result;\n    }\n\n    function useLiveQuery(querier, deps, defaultResult) {\n        return useObservable(function () { return dexie.liveQuery(querier); }, deps || [], defaultResult);\n    }\n\n    function usePermissions(firstArg, table, obj) {\n        if (!firstArg)\n            throw new TypeError(\"Invalid arguments to usePermissions(): undefined or null\");\n        var db;\n        if (arguments.length >= 3) {\n            if (!('transaction' in firstArg)) {\n                // Using ducktyping instead of instanceof in case there are multiple Dexie modules in app.\n                // First arg is  ensures first arg is a Dexie instance\n                throw new TypeError(\"Invalid arguments to usePermission(db, table, obj): 1st arg must be a Dexie instance\");\n            }\n            if (typeof table !== 'string')\n                throw new TypeError(\"Invalid arguments to usePermission(db, table, obj): 2nd arg must be string\");\n            if (!obj || typeof obj !== 'object')\n                throw new TypeError(\"Invalid arguments to usePermission(db, table, obj): 3rd arg must be an object\");\n            db = firstArg;\n        }\n        else {\n            if (firstArg instanceof dexie.Dexie)\n                throw new TypeError(\"Invalid arguments to usePermission(db, table, obj): Missing table and obj arguments.\");\n            if (typeof firstArg.table === 'function' &&\n                typeof firstArg.db === 'object') {\n                db = firstArg.db;\n                obj = firstArg;\n                table = firstArg.table();\n            }\n            else {\n                throw new TypeError(\"Invalid arguments to usePermissions(). \" +\n                    \"Expected usePermissions(entity: DexieCloudEntity) or \" +\n                    \"usePermissions(db: Dexie, table: string, obj: DexieCloudObject)\");\n            }\n        }\n        if (!('cloud' in db))\n            throw new Error(\"usePermissions() is only for Dexie Cloud but there's no dexie-cloud-addon active in given db.\");\n        if (!('permissions' in db['cloud']))\n            throw new Error(\"usePermissions() requires a newer version of dexie-cloud-addon. Please upgrade it.\");\n        return useObservable(\n        // @ts-ignore\n        function () { return db.cloud.permissions(obj, table); }, [obj.realmId, obj.owner, table]);\n    }\n\n    exports.useLiveQuery = useLiveQuery;\n    exports.useObservable = useObservable;\n    exports.usePermissions = usePermissions;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=dexie-react-hooks.js.map\n","/*\n * Dexie.js - a minimalistic wrapper for IndexedDB\n * ===============================================\n *\n * By David Fahlander, david.fahlander@gmail.com\n *\n * Version 3.2.0, Thu Nov 18 2021\n *\n * http://dexie.org\n *\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\n */\n \nconst _global = typeof globalThis !== 'undefined' ? globalThis :\n    typeof self !== 'undefined' ? self :\n        typeof window !== 'undefined' ? window :\n            global;\n\nconst keys = Object.keys;\nconst isArray = Array.isArray;\nif (typeof Promise !== 'undefined' && !_global.Promise) {\n    _global.Promise = Promise;\n}\nfunction extend(obj, extension) {\n    if (typeof extension !== 'object')\n        return obj;\n    keys(extension).forEach(function (key) {\n        obj[key] = extension[key];\n    });\n    return obj;\n}\nconst getProto = Object.getPrototypeOf;\nconst _hasOwn = {}.hasOwnProperty;\nfunction hasOwn(obj, prop) {\n    return _hasOwn.call(obj, prop);\n}\nfunction props(proto, extension) {\n    if (typeof extension === 'function')\n        extension = extension(getProto(proto));\n    (typeof Reflect === \"undefined\" ? keys : Reflect.ownKeys)(extension).forEach(key => {\n        setProp(proto, key, extension[key]);\n    });\n}\nconst defineProperty = Object.defineProperty;\nfunction setProp(obj, prop, functionOrGetSet, options) {\n    defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, \"get\") && typeof functionOrGetSet.get === 'function' ?\n        { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } :\n        { value: functionOrGetSet, configurable: true, writable: true }, options));\n}\nfunction derive(Child) {\n    return {\n        from: function (Parent) {\n            Child.prototype = Object.create(Parent.prototype);\n            setProp(Child.prototype, \"constructor\", Child);\n            return {\n                extend: props.bind(null, Child.prototype)\n            };\n        }\n    };\n}\nconst getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nfunction getPropertyDescriptor(obj, prop) {\n    const pd = getOwnPropertyDescriptor(obj, prop);\n    let proto;\n    return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);\n}\nconst _slice = [].slice;\nfunction slice(args, start, end) {\n    return _slice.call(args, start, end);\n}\nfunction override(origFunc, overridedFactory) {\n    return overridedFactory(origFunc);\n}\nfunction assert(b) {\n    if (!b)\n        throw new Error(\"Assertion Failed\");\n}\nfunction asap$1(fn) {\n    if (_global.setImmediate)\n        setImmediate(fn);\n    else\n        setTimeout(fn, 0);\n}\nfunction arrayToObject(array, extractor) {\n    return array.reduce((result, item, i) => {\n        var nameAndValue = extractor(item, i);\n        if (nameAndValue)\n            result[nameAndValue[0]] = nameAndValue[1];\n        return result;\n    }, {});\n}\nfunction tryCatch(fn, onerror, args) {\n    try {\n        fn.apply(null, args);\n    }\n    catch (ex) {\n        onerror && onerror(ex);\n    }\n}\nfunction getByKeyPath(obj, keyPath) {\n    if (hasOwn(obj, keyPath))\n        return obj[keyPath];\n    if (!keyPath)\n        return obj;\n    if (typeof keyPath !== 'string') {\n        var rv = [];\n        for (var i = 0, l = keyPath.length; i < l; ++i) {\n            var val = getByKeyPath(obj, keyPath[i]);\n            rv.push(val);\n        }\n        return rv;\n    }\n    var period = keyPath.indexOf('.');\n    if (period !== -1) {\n        var innerObj = obj[keyPath.substr(0, period)];\n        return innerObj === undefined ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));\n    }\n    return undefined;\n}\nfunction setByKeyPath(obj, keyPath, value) {\n    if (!obj || keyPath === undefined)\n        return;\n    if ('isFrozen' in Object && Object.isFrozen(obj))\n        return;\n    if (typeof keyPath !== 'string' && 'length' in keyPath) {\n        assert(typeof value !== 'string' && 'length' in value);\n        for (var i = 0, l = keyPath.length; i < l; ++i) {\n            setByKeyPath(obj, keyPath[i], value[i]);\n        }\n    }\n    else {\n        var period = keyPath.indexOf('.');\n        if (period !== -1) {\n            var currentKeyPath = keyPath.substr(0, period);\n            var remainingKeyPath = keyPath.substr(period + 1);\n            if (remainingKeyPath === \"\")\n                if (value === undefined) {\n                    if (isArray(obj) && !isNaN(parseInt(currentKeyPath)))\n                        obj.splice(currentKeyPath, 1);\n                    else\n                        delete obj[currentKeyPath];\n                }\n                else\n                    obj[currentKeyPath] = value;\n            else {\n                var innerObj = obj[currentKeyPath];\n                if (!innerObj)\n                    innerObj = (obj[currentKeyPath] = {});\n                setByKeyPath(innerObj, remainingKeyPath, value);\n            }\n        }\n        else {\n            if (value === undefined) {\n                if (isArray(obj) && !isNaN(parseInt(keyPath)))\n                    obj.splice(keyPath, 1);\n                else\n                    delete obj[keyPath];\n            }\n            else\n                obj[keyPath] = value;\n        }\n    }\n}\nfunction delByKeyPath(obj, keyPath) {\n    if (typeof keyPath === 'string')\n        setByKeyPath(obj, keyPath, undefined);\n    else if ('length' in keyPath)\n        [].map.call(keyPath, function (kp) {\n            setByKeyPath(obj, kp, undefined);\n        });\n}\nfunction shallowClone(obj) {\n    var rv = {};\n    for (var m in obj) {\n        if (hasOwn(obj, m))\n            rv[m] = obj[m];\n    }\n    return rv;\n}\nconst concat = [].concat;\nfunction flatten(a) {\n    return concat.apply([], a);\n}\nconst intrinsicTypeNames = \"Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey\"\n    .split(',').concat(flatten([8, 16, 32, 64].map(num => [\"Int\", \"Uint\", \"Float\"].map(t => t + num + \"Array\")))).filter(t => _global[t]);\nconst intrinsicTypes = intrinsicTypeNames.map(t => _global[t]);\narrayToObject(intrinsicTypeNames, x => [x, true]);\nlet circularRefs = null;\nfunction deepClone(any) {\n    circularRefs = typeof WeakMap !== 'undefined' && new WeakMap();\n    const rv = innerDeepClone(any);\n    circularRefs = null;\n    return rv;\n}\nfunction innerDeepClone(any) {\n    if (!any || typeof any !== 'object')\n        return any;\n    let rv = circularRefs && circularRefs.get(any);\n    if (rv)\n        return rv;\n    if (isArray(any)) {\n        rv = [];\n        circularRefs && circularRefs.set(any, rv);\n        for (var i = 0, l = any.length; i < l; ++i) {\n            rv.push(innerDeepClone(any[i]));\n        }\n    }\n    else if (intrinsicTypes.indexOf(any.constructor) >= 0) {\n        rv = any;\n    }\n    else {\n        const proto = getProto(any);\n        rv = proto === Object.prototype ? {} : Object.create(proto);\n        circularRefs && circularRefs.set(any, rv);\n        for (var prop in any) {\n            if (hasOwn(any, prop)) {\n                rv[prop] = innerDeepClone(any[prop]);\n            }\n        }\n    }\n    return rv;\n}\nconst { toString } = {};\nfunction toStringTag(o) {\n    return toString.call(o).slice(8, -1);\n}\nconst iteratorSymbol = typeof Symbol !== 'undefined' ?\n    Symbol.iterator :\n    '@@iterator';\nconst getIteratorOf = typeof iteratorSymbol === \"symbol\" ? function (x) {\n    var i;\n    return x != null && (i = x[iteratorSymbol]) && i.apply(x);\n} : function () { return null; };\nconst NO_CHAR_ARRAY = {};\nfunction getArrayOf(arrayLike) {\n    var i, a, x, it;\n    if (arguments.length === 1) {\n        if (isArray(arrayLike))\n            return arrayLike.slice();\n        if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string')\n            return [arrayLike];\n        if ((it = getIteratorOf(arrayLike))) {\n            a = [];\n            while ((x = it.next()), !x.done)\n                a.push(x.value);\n            return a;\n        }\n        if (arrayLike == null)\n            return [arrayLike];\n        i = arrayLike.length;\n        if (typeof i === 'number') {\n            a = new Array(i);\n            while (i--)\n                a[i] = arrayLike[i];\n            return a;\n        }\n        return [arrayLike];\n    }\n    i = arguments.length;\n    a = new Array(i);\n    while (i--)\n        a[i] = arguments[i];\n    return a;\n}\nconst isAsyncFunction = typeof Symbol !== 'undefined'\n    ? (fn) => fn[Symbol.toStringTag] === 'AsyncFunction'\n    : () => false;\n\nvar debug = typeof location !== 'undefined' &&\n    /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\nfunction setDebug(value, filter) {\n    debug = value;\n    libraryFilter = filter;\n}\nvar libraryFilter = () => true;\nconst NEEDS_THROW_FOR_STACK = !new Error(\"\").stack;\nfunction getErrorWithStack() {\n    if (NEEDS_THROW_FOR_STACK)\n        try {\n            getErrorWithStack.arguments;\n            throw new Error();\n        }\n        catch (e) {\n            return e;\n        }\n    return new Error();\n}\nfunction prettyStack(exception, numIgnoredFrames) {\n    var stack = exception.stack;\n    if (!stack)\n        return \"\";\n    numIgnoredFrames = (numIgnoredFrames || 0);\n    if (stack.indexOf(exception.name) === 0)\n        numIgnoredFrames += (exception.name + exception.message).split('\\n').length;\n    return stack.split('\\n')\n        .slice(numIgnoredFrames)\n        .filter(libraryFilter)\n        .map(frame => \"\\n\" + frame)\n        .join('');\n}\n\nvar dexieErrorNames = [\n    'Modify',\n    'Bulk',\n    'OpenFailed',\n    'VersionChange',\n    'Schema',\n    'Upgrade',\n    'InvalidTable',\n    'MissingAPI',\n    'NoSuchDatabase',\n    'InvalidArgument',\n    'SubTransaction',\n    'Unsupported',\n    'Internal',\n    'DatabaseClosed',\n    'PrematureCommit',\n    'ForeignAwait'\n];\nvar idbDomErrorNames = [\n    'Unknown',\n    'Constraint',\n    'Data',\n    'TransactionInactive',\n    'ReadOnly',\n    'Version',\n    'NotFound',\n    'InvalidState',\n    'InvalidAccess',\n    'Abort',\n    'Timeout',\n    'QuotaExceeded',\n    'Syntax',\n    'DataClone'\n];\nvar errorList = dexieErrorNames.concat(idbDomErrorNames);\nvar defaultTexts = {\n    VersionChanged: \"Database version changed by other database connection\",\n    DatabaseClosed: \"Database has been closed\",\n    Abort: \"Transaction aborted\",\n    TransactionInactive: \"Transaction has already completed or failed\",\n    MissingAPI: \"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb\"\n};\nfunction DexieError(name, msg) {\n    this._e = getErrorWithStack();\n    this.name = name;\n    this.message = msg;\n}\nderive(DexieError).from(Error).extend({\n    stack: {\n        get: function () {\n            return this._stack ||\n                (this._stack = this.name + \": \" + this.message + prettyStack(this._e, 2));\n        }\n    },\n    toString: function () { return this.name + \": \" + this.message; }\n});\nfunction getMultiErrorMessage(msg, failures) {\n    return msg + \". Errors: \" + Object.keys(failures)\n        .map(key => failures[key].toString())\n        .filter((v, i, s) => s.indexOf(v) === i)\n        .join('\\n');\n}\nfunction ModifyError(msg, failures, successCount, failedKeys) {\n    this._e = getErrorWithStack();\n    this.failures = failures;\n    this.failedKeys = failedKeys;\n    this.successCount = successCount;\n    this.message = getMultiErrorMessage(msg, failures);\n}\nderive(ModifyError).from(DexieError);\nfunction BulkError(msg, failures) {\n    this._e = getErrorWithStack();\n    this.name = \"BulkError\";\n    this.failures = Object.keys(failures).map(pos => failures[pos]);\n    this.failuresByPos = failures;\n    this.message = getMultiErrorMessage(msg, failures);\n}\nderive(BulkError).from(DexieError);\nvar errnames = errorList.reduce((obj, name) => (obj[name] = name + \"Error\", obj), {});\nconst BaseException = DexieError;\nvar exceptions = errorList.reduce((obj, name) => {\n    var fullName = name + \"Error\";\n    function DexieError(msgOrInner, inner) {\n        this._e = getErrorWithStack();\n        this.name = fullName;\n        if (!msgOrInner) {\n            this.message = defaultTexts[name] || fullName;\n            this.inner = null;\n        }\n        else if (typeof msgOrInner === 'string') {\n            this.message = `${msgOrInner}${!inner ? '' : '\\n ' + inner}`;\n            this.inner = inner || null;\n        }\n        else if (typeof msgOrInner === 'object') {\n            this.message = `${msgOrInner.name} ${msgOrInner.message}`;\n            this.inner = msgOrInner;\n        }\n    }\n    derive(DexieError).from(BaseException);\n    obj[name] = DexieError;\n    return obj;\n}, {});\nexceptions.Syntax = SyntaxError;\nexceptions.Type = TypeError;\nexceptions.Range = RangeError;\nvar exceptionMap = idbDomErrorNames.reduce((obj, name) => {\n    obj[name + \"Error\"] = exceptions[name];\n    return obj;\n}, {});\nfunction mapError(domError, message) {\n    if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])\n        return domError;\n    var rv = new exceptionMap[domError.name](message || domError.message, domError);\n    if (\"stack\" in domError) {\n        setProp(rv, \"stack\", { get: function () {\n                return this.inner.stack;\n            } });\n    }\n    return rv;\n}\nvar fullNameExceptions = errorList.reduce((obj, name) => {\n    if ([\"Syntax\", \"Type\", \"Range\"].indexOf(name) === -1)\n        obj[name + \"Error\"] = exceptions[name];\n    return obj;\n}, {});\nfullNameExceptions.ModifyError = ModifyError;\nfullNameExceptions.DexieError = DexieError;\nfullNameExceptions.BulkError = BulkError;\n\nfunction nop() { }\nfunction mirror(val) { return val; }\nfunction pureFunctionChain(f1, f2) {\n    if (f1 == null || f1 === mirror)\n        return f2;\n    return function (val) {\n        return f2(f1(val));\n    };\n}\nfunction callBoth(on1, on2) {\n    return function () {\n        on1.apply(this, arguments);\n        on2.apply(this, arguments);\n    };\n}\nfunction hookCreatingChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        var res = f1.apply(this, arguments);\n        if (res !== undefined)\n            arguments[0] = res;\n        var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n        this.onsuccess = null;\n        this.onerror = null;\n        var res2 = f2.apply(this, arguments);\n        if (onsuccess)\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror)\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        return res2 !== undefined ? res2 : res;\n    };\n}\nfunction hookDeletingChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        f1.apply(this, arguments);\n        var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n        this.onsuccess = this.onerror = null;\n        f2.apply(this, arguments);\n        if (onsuccess)\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror)\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n    };\n}\nfunction hookUpdatingChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function (modifications) {\n        var res = f1.apply(this, arguments);\n        extend(modifications, res);\n        var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n        this.onsuccess = null;\n        this.onerror = null;\n        var res2 = f2.apply(this, arguments);\n        if (onsuccess)\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror)\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        return res === undefined ?\n            (res2 === undefined ? undefined : res2) :\n            (extend(res, res2));\n    };\n}\nfunction reverseStoppableEventChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        if (f2.apply(this, arguments) === false)\n            return false;\n        return f1.apply(this, arguments);\n    };\n}\nfunction promisableChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        var res = f1.apply(this, arguments);\n        if (res && typeof res.then === 'function') {\n            var thiz = this, i = arguments.length, args = new Array(i);\n            while (i--)\n                args[i] = arguments[i];\n            return res.then(function () {\n                return f2.apply(thiz, args);\n            });\n        }\n        return f2.apply(this, arguments);\n    };\n}\n\nvar INTERNAL = {};\nconst LONG_STACKS_CLIP_LIMIT = 100,\nMAX_LONG_STACKS = 20, ZONE_ECHO_LIMIT = 100, [resolvedNativePromise, nativePromiseProto, resolvedGlobalPromise] = typeof Promise === 'undefined' ?\n    [] :\n    (() => {\n        let globalP = Promise.resolve();\n        if (typeof crypto === 'undefined' || !crypto.subtle)\n            return [globalP, getProto(globalP), globalP];\n        const nativeP = crypto.subtle.digest(\"SHA-512\", new Uint8Array([0]));\n        return [\n            nativeP,\n            getProto(nativeP),\n            globalP\n        ];\n    })(), nativePromiseThen = nativePromiseProto && nativePromiseProto.then;\nconst NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;\nconst patchGlobalPromise = !!resolvedGlobalPromise;\nvar stack_being_generated = false;\nvar schedulePhysicalTick = resolvedGlobalPromise ?\n    () => { resolvedGlobalPromise.then(physicalTick); }\n    :\n        _global.setImmediate ?\n            setImmediate.bind(null, physicalTick) :\n            _global.MutationObserver ?\n                () => {\n                    var hiddenDiv = document.createElement(\"div\");\n                    (new MutationObserver(() => {\n                        physicalTick();\n                        hiddenDiv = null;\n                    })).observe(hiddenDiv, { attributes: true });\n                    hiddenDiv.setAttribute('i', '1');\n                } :\n                () => { setTimeout(physicalTick, 0); };\nvar asap = function (callback, args) {\n    microtickQueue.push([callback, args]);\n    if (needsNewPhysicalTick) {\n        schedulePhysicalTick();\n        needsNewPhysicalTick = false;\n    }\n};\nvar isOutsideMicroTick = true,\nneedsNewPhysicalTick = true,\nunhandledErrors = [],\nrejectingErrors = [],\ncurrentFulfiller = null, rejectionMapper = mirror;\nvar globalPSD = {\n    id: 'global',\n    global: true,\n    ref: 0,\n    unhandleds: [],\n    onunhandled: globalError,\n    pgp: false,\n    env: {},\n    finalize: function () {\n        this.unhandleds.forEach(uh => {\n            try {\n                globalError(uh[0], uh[1]);\n            }\n            catch (e) { }\n        });\n    }\n};\nvar PSD = globalPSD;\nvar microtickQueue = [];\nvar numScheduledCalls = 0;\nvar tickFinalizers = [];\nfunction DexiePromise(fn) {\n    if (typeof this !== 'object')\n        throw new TypeError('Promises must be constructed via new');\n    this._listeners = [];\n    this.onuncatched = nop;\n    this._lib = false;\n    var psd = (this._PSD = PSD);\n    if (debug) {\n        this._stackHolder = getErrorWithStack();\n        this._prev = null;\n        this._numPrev = 0;\n    }\n    if (typeof fn !== 'function') {\n        if (fn !== INTERNAL)\n            throw new TypeError('Not a function');\n        this._state = arguments[1];\n        this._value = arguments[2];\n        if (this._state === false)\n            handleRejection(this, this._value);\n        return;\n    }\n    this._state = null;\n    this._value = null;\n    ++psd.ref;\n    executePromiseTask(this, fn);\n}\nconst thenProp = {\n    get: function () {\n        var psd = PSD, microTaskId = totalEchoes;\n        function then(onFulfilled, onRejected) {\n            var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);\n            const cleanup = possibleAwait && !decrementExpectedAwaits();\n            var rv = new DexiePromise((resolve, reject) => {\n                propagateToListener(this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));\n            });\n            debug && linkToPreviousPromise(rv, this);\n            return rv;\n        }\n        then.prototype = INTERNAL;\n        return then;\n    },\n    set: function (value) {\n        setProp(this, 'then', value && value.prototype === INTERNAL ?\n            thenProp :\n            {\n                get: function () {\n                    return value;\n                },\n                set: thenProp.set\n            });\n    }\n};\nprops(DexiePromise.prototype, {\n    then: thenProp,\n    _then: function (onFulfilled, onRejected) {\n        propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));\n    },\n    catch: function (onRejected) {\n        if (arguments.length === 1)\n            return this.then(null, onRejected);\n        var type = arguments[0], handler = arguments[1];\n        return typeof type === 'function' ? this.then(null, err =>\n        err instanceof type ? handler(err) : PromiseReject(err))\n            : this.then(null, err =>\n            err && err.name === type ? handler(err) : PromiseReject(err));\n    },\n    finally: function (onFinally) {\n        return this.then(value => {\n            onFinally();\n            return value;\n        }, err => {\n            onFinally();\n            return PromiseReject(err);\n        });\n    },\n    stack: {\n        get: function () {\n            if (this._stack)\n                return this._stack;\n            try {\n                stack_being_generated = true;\n                var stacks = getStack(this, [], MAX_LONG_STACKS);\n                var stack = stacks.join(\"\\nFrom previous: \");\n                if (this._state !== null)\n                    this._stack = stack;\n                return stack;\n            }\n            finally {\n                stack_being_generated = false;\n            }\n        }\n    },\n    timeout: function (ms, msg) {\n        return ms < Infinity ?\n            new DexiePromise((resolve, reject) => {\n                var handle = setTimeout(() => reject(new exceptions.Timeout(msg)), ms);\n                this.then(resolve, reject).finally(clearTimeout.bind(null, handle));\n            }) : this;\n    }\n});\nif (typeof Symbol !== 'undefined' && Symbol.toStringTag)\n    setProp(DexiePromise.prototype, Symbol.toStringTag, 'Dexie.Promise');\nglobalPSD.env = snapShot();\nfunction Listener(onFulfilled, onRejected, resolve, reject, zone) {\n    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n    this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n    this.resolve = resolve;\n    this.reject = reject;\n    this.psd = zone;\n}\nprops(DexiePromise, {\n    all: function () {\n        var values = getArrayOf.apply(null, arguments)\n            .map(onPossibleParallellAsync);\n        return new DexiePromise(function (resolve, reject) {\n            if (values.length === 0)\n                resolve([]);\n            var remaining = values.length;\n            values.forEach((a, i) => DexiePromise.resolve(a).then(x => {\n                values[i] = x;\n                if (!--remaining)\n                    resolve(values);\n            }, reject));\n        });\n    },\n    resolve: value => {\n        if (value instanceof DexiePromise)\n            return value;\n        if (value && typeof value.then === 'function')\n            return new DexiePromise((resolve, reject) => {\n                value.then(resolve, reject);\n            });\n        var rv = new DexiePromise(INTERNAL, true, value);\n        linkToPreviousPromise(rv, currentFulfiller);\n        return rv;\n    },\n    reject: PromiseReject,\n    race: function () {\n        var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n        return new DexiePromise((resolve, reject) => {\n            values.map(value => DexiePromise.resolve(value).then(resolve, reject));\n        });\n    },\n    PSD: {\n        get: () => PSD,\n        set: value => PSD = value\n    },\n    totalEchoes: { get: () => totalEchoes },\n    newPSD: newScope,\n    usePSD: usePSD,\n    scheduler: {\n        get: () => asap,\n        set: value => { asap = value; }\n    },\n    rejectionMapper: {\n        get: () => rejectionMapper,\n        set: value => { rejectionMapper = value; }\n    },\n    follow: (fn, zoneProps) => {\n        return new DexiePromise((resolve, reject) => {\n            return newScope((resolve, reject) => {\n                var psd = PSD;\n                psd.unhandleds = [];\n                psd.onunhandled = reject;\n                psd.finalize = callBoth(function () {\n                    run_at_end_of_this_or_next_physical_tick(() => {\n                        this.unhandleds.length === 0 ? resolve() : reject(this.unhandleds[0]);\n                    });\n                }, psd.finalize);\n                fn();\n            }, zoneProps, resolve, reject);\n        });\n    }\n});\nif (NativePromise) {\n    if (NativePromise.allSettled)\n        setProp(DexiePromise, \"allSettled\", function () {\n            const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n            return new DexiePromise(resolve => {\n                if (possiblePromises.length === 0)\n                    resolve([]);\n                let remaining = possiblePromises.length;\n                const results = new Array(remaining);\n                possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then(value => results[i] = { status: \"fulfilled\", value }, reason => results[i] = { status: \"rejected\", reason })\n                    .then(() => --remaining || resolve(results)));\n            });\n        });\n    if (NativePromise.any && typeof AggregateError !== 'undefined')\n        setProp(DexiePromise, \"any\", function () {\n            const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n            return new DexiePromise((resolve, reject) => {\n                if (possiblePromises.length === 0)\n                    reject(new AggregateError([]));\n                let remaining = possiblePromises.length;\n                const failures = new Array(remaining);\n                possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then(value => resolve(value), failure => {\n                    failures[i] = failure;\n                    if (!--remaining)\n                        reject(new AggregateError(failures));\n                }));\n            });\n        });\n}\nfunction executePromiseTask(promise, fn) {\n    try {\n        fn(value => {\n            if (promise._state !== null)\n                return;\n            if (value === promise)\n                throw new TypeError('A promise cannot be resolved with itself.');\n            var shouldExecuteTick = promise._lib && beginMicroTickScope();\n            if (value && typeof value.then === 'function') {\n                executePromiseTask(promise, (resolve, reject) => {\n                    value instanceof DexiePromise ?\n                        value._then(resolve, reject) :\n                        value.then(resolve, reject);\n                });\n            }\n            else {\n                promise._state = true;\n                promise._value = value;\n                propagateAllListeners(promise);\n            }\n            if (shouldExecuteTick)\n                endMicroTickScope();\n        }, handleRejection.bind(null, promise));\n    }\n    catch (ex) {\n        handleRejection(promise, ex);\n    }\n}\nfunction handleRejection(promise, reason) {\n    rejectingErrors.push(reason);\n    if (promise._state !== null)\n        return;\n    var shouldExecuteTick = promise._lib && beginMicroTickScope();\n    reason = rejectionMapper(reason);\n    promise._state = false;\n    promise._value = reason;\n    debug && reason !== null && typeof reason === 'object' && !reason._promise && tryCatch(() => {\n        var origProp = getPropertyDescriptor(reason, \"stack\");\n        reason._promise = promise;\n        setProp(reason, \"stack\", {\n            get: () => stack_being_generated ?\n                origProp && (origProp.get ?\n                    origProp.get.apply(reason) :\n                    origProp.value) :\n                promise.stack\n        });\n    });\n    addPossiblyUnhandledError(promise);\n    propagateAllListeners(promise);\n    if (shouldExecuteTick)\n        endMicroTickScope();\n}\nfunction propagateAllListeners(promise) {\n    var listeners = promise._listeners;\n    promise._listeners = [];\n    for (var i = 0, len = listeners.length; i < len; ++i) {\n        propagateToListener(promise, listeners[i]);\n    }\n    var psd = promise._PSD;\n    --psd.ref || psd.finalize();\n    if (numScheduledCalls === 0) {\n        ++numScheduledCalls;\n        asap(() => {\n            if (--numScheduledCalls === 0)\n                finalizePhysicalTick();\n        }, []);\n    }\n}\nfunction propagateToListener(promise, listener) {\n    if (promise._state === null) {\n        promise._listeners.push(listener);\n        return;\n    }\n    var cb = promise._state ? listener.onFulfilled : listener.onRejected;\n    if (cb === null) {\n        return (promise._state ? listener.resolve : listener.reject)(promise._value);\n    }\n    ++listener.psd.ref;\n    ++numScheduledCalls;\n    asap(callListener, [cb, promise, listener]);\n}\nfunction callListener(cb, promise, listener) {\n    try {\n        currentFulfiller = promise;\n        var ret, value = promise._value;\n        if (promise._state) {\n            ret = cb(value);\n        }\n        else {\n            if (rejectingErrors.length)\n                rejectingErrors = [];\n            ret = cb(value);\n            if (rejectingErrors.indexOf(value) === -1)\n                markErrorAsHandled(promise);\n        }\n        listener.resolve(ret);\n    }\n    catch (e) {\n        listener.reject(e);\n    }\n    finally {\n        currentFulfiller = null;\n        if (--numScheduledCalls === 0)\n            finalizePhysicalTick();\n        --listener.psd.ref || listener.psd.finalize();\n    }\n}\nfunction getStack(promise, stacks, limit) {\n    if (stacks.length === limit)\n        return stacks;\n    var stack = \"\";\n    if (promise._state === false) {\n        var failure = promise._value, errorName, message;\n        if (failure != null) {\n            errorName = failure.name || \"Error\";\n            message = failure.message || failure;\n            stack = prettyStack(failure, 0);\n        }\n        else {\n            errorName = failure;\n            message = \"\";\n        }\n        stacks.push(errorName + (message ? \": \" + message : \"\") + stack);\n    }\n    if (debug) {\n        stack = prettyStack(promise._stackHolder, 2);\n        if (stack && stacks.indexOf(stack) === -1)\n            stacks.push(stack);\n        if (promise._prev)\n            getStack(promise._prev, stacks, limit);\n    }\n    return stacks;\n}\nfunction linkToPreviousPromise(promise, prev) {\n    var numPrev = prev ? prev._numPrev + 1 : 0;\n    if (numPrev < LONG_STACKS_CLIP_LIMIT) {\n        promise._prev = prev;\n        promise._numPrev = numPrev;\n    }\n}\nfunction physicalTick() {\n    beginMicroTickScope() && endMicroTickScope();\n}\nfunction beginMicroTickScope() {\n    var wasRootExec = isOutsideMicroTick;\n    isOutsideMicroTick = false;\n    needsNewPhysicalTick = false;\n    return wasRootExec;\n}\nfunction endMicroTickScope() {\n    var callbacks, i, l;\n    do {\n        while (microtickQueue.length > 0) {\n            callbacks = microtickQueue;\n            microtickQueue = [];\n            l = callbacks.length;\n            for (i = 0; i < l; ++i) {\n                var item = callbacks[i];\n                item[0].apply(null, item[1]);\n            }\n        }\n    } while (microtickQueue.length > 0);\n    isOutsideMicroTick = true;\n    needsNewPhysicalTick = true;\n}\nfunction finalizePhysicalTick() {\n    var unhandledErrs = unhandledErrors;\n    unhandledErrors = [];\n    unhandledErrs.forEach(p => {\n        p._PSD.onunhandled.call(null, p._value, p);\n    });\n    var finalizers = tickFinalizers.slice(0);\n    var i = finalizers.length;\n    while (i)\n        finalizers[--i]();\n}\nfunction run_at_end_of_this_or_next_physical_tick(fn) {\n    function finalizer() {\n        fn();\n        tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);\n    }\n    tickFinalizers.push(finalizer);\n    ++numScheduledCalls;\n    asap(() => {\n        if (--numScheduledCalls === 0)\n            finalizePhysicalTick();\n    }, []);\n}\nfunction addPossiblyUnhandledError(promise) {\n    if (!unhandledErrors.some(p => p._value === promise._value))\n        unhandledErrors.push(promise);\n}\nfunction markErrorAsHandled(promise) {\n    var i = unhandledErrors.length;\n    while (i)\n        if (unhandledErrors[--i]._value === promise._value) {\n            unhandledErrors.splice(i, 1);\n            return;\n        }\n}\nfunction PromiseReject(reason) {\n    return new DexiePromise(INTERNAL, false, reason);\n}\nfunction wrap(fn, errorCatcher) {\n    var psd = PSD;\n    return function () {\n        var wasRootExec = beginMicroTickScope(), outerScope = PSD;\n        try {\n            switchToZone(psd, true);\n            return fn.apply(this, arguments);\n        }\n        catch (e) {\n            errorCatcher && errorCatcher(e);\n        }\n        finally {\n            switchToZone(outerScope, false);\n            if (wasRootExec)\n                endMicroTickScope();\n        }\n    };\n}\nconst task = { awaits: 0, echoes: 0, id: 0 };\nvar taskCounter = 0;\nvar zoneStack = [];\nvar zoneEchoes = 0;\nvar totalEchoes = 0;\nvar zone_id_counter = 0;\nfunction newScope(fn, props, a1, a2) {\n    var parent = PSD, psd = Object.create(parent);\n    psd.parent = parent;\n    psd.ref = 0;\n    psd.global = false;\n    psd.id = ++zone_id_counter;\n    var globalEnv = globalPSD.env;\n    psd.env = patchGlobalPromise ? {\n        Promise: DexiePromise,\n        PromiseProp: { value: DexiePromise, configurable: true, writable: true },\n        all: DexiePromise.all,\n        race: DexiePromise.race,\n        allSettled: DexiePromise.allSettled,\n        any: DexiePromise.any,\n        resolve: DexiePromise.resolve,\n        reject: DexiePromise.reject,\n        nthen: getPatchedPromiseThen(globalEnv.nthen, psd),\n        gthen: getPatchedPromiseThen(globalEnv.gthen, psd)\n    } : {};\n    if (props)\n        extend(psd, props);\n    ++parent.ref;\n    psd.finalize = function () {\n        --this.parent.ref || this.parent.finalize();\n    };\n    var rv = usePSD(psd, fn, a1, a2);\n    if (psd.ref === 0)\n        psd.finalize();\n    return rv;\n}\nfunction incrementExpectedAwaits() {\n    if (!task.id)\n        task.id = ++taskCounter;\n    ++task.awaits;\n    task.echoes += ZONE_ECHO_LIMIT;\n    return task.id;\n}\nfunction decrementExpectedAwaits() {\n    if (!task.awaits)\n        return false;\n    if (--task.awaits === 0)\n        task.id = 0;\n    task.echoes = task.awaits * ZONE_ECHO_LIMIT;\n    return true;\n}\nif (('' + nativePromiseThen).indexOf('[native code]') === -1) {\n    incrementExpectedAwaits = decrementExpectedAwaits = nop;\n}\nfunction onPossibleParallellAsync(possiblePromise) {\n    if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {\n        incrementExpectedAwaits();\n        return possiblePromise.then(x => {\n            decrementExpectedAwaits();\n            return x;\n        }, e => {\n            decrementExpectedAwaits();\n            return rejection(e);\n        });\n    }\n    return possiblePromise;\n}\nfunction zoneEnterEcho(targetZone) {\n    ++totalEchoes;\n    if (!task.echoes || --task.echoes === 0) {\n        task.echoes = task.id = 0;\n    }\n    zoneStack.push(PSD);\n    switchToZone(targetZone, true);\n}\nfunction zoneLeaveEcho() {\n    var zone = zoneStack[zoneStack.length - 1];\n    zoneStack.pop();\n    switchToZone(zone, false);\n}\nfunction switchToZone(targetZone, bEnteringZone) {\n    var currentZone = PSD;\n    if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {\n        enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);\n    }\n    if (targetZone === PSD)\n        return;\n    PSD = targetZone;\n    if (currentZone === globalPSD)\n        globalPSD.env = snapShot();\n    if (patchGlobalPromise) {\n        var GlobalPromise = globalPSD.env.Promise;\n        var targetEnv = targetZone.env;\n        nativePromiseProto.then = targetEnv.nthen;\n        GlobalPromise.prototype.then = targetEnv.gthen;\n        if (currentZone.global || targetZone.global) {\n            Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);\n            GlobalPromise.all = targetEnv.all;\n            GlobalPromise.race = targetEnv.race;\n            GlobalPromise.resolve = targetEnv.resolve;\n            GlobalPromise.reject = targetEnv.reject;\n            if (targetEnv.allSettled)\n                GlobalPromise.allSettled = targetEnv.allSettled;\n            if (targetEnv.any)\n                GlobalPromise.any = targetEnv.any;\n        }\n    }\n}\nfunction snapShot() {\n    var GlobalPromise = _global.Promise;\n    return patchGlobalPromise ? {\n        Promise: GlobalPromise,\n        PromiseProp: Object.getOwnPropertyDescriptor(_global, \"Promise\"),\n        all: GlobalPromise.all,\n        race: GlobalPromise.race,\n        allSettled: GlobalPromise.allSettled,\n        any: GlobalPromise.any,\n        resolve: GlobalPromise.resolve,\n        reject: GlobalPromise.reject,\n        nthen: nativePromiseProto.then,\n        gthen: GlobalPromise.prototype.then\n    } : {};\n}\nfunction usePSD(psd, fn, a1, a2, a3) {\n    var outerScope = PSD;\n    try {\n        switchToZone(psd, true);\n        return fn(a1, a2, a3);\n    }\n    finally {\n        switchToZone(outerScope, false);\n    }\n}\nfunction enqueueNativeMicroTask(job) {\n    nativePromiseThen.call(resolvedNativePromise, job);\n}\nfunction nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {\n    return typeof fn !== 'function' ? fn : function () {\n        var outerZone = PSD;\n        if (possibleAwait)\n            incrementExpectedAwaits();\n        switchToZone(zone, true);\n        try {\n            return fn.apply(this, arguments);\n        }\n        finally {\n            switchToZone(outerZone, false);\n            if (cleanup)\n                enqueueNativeMicroTask(decrementExpectedAwaits);\n        }\n    };\n}\nfunction getPatchedPromiseThen(origThen, zone) {\n    return function (onResolved, onRejected) {\n        return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone), nativeAwaitCompatibleWrap(onRejected, zone));\n    };\n}\nconst UNHANDLEDREJECTION = \"unhandledrejection\";\nfunction globalError(err, promise) {\n    var rv;\n    try {\n        rv = promise.onuncatched(err);\n    }\n    catch (e) { }\n    if (rv !== false)\n        try {\n            var event, eventData = { promise: promise, reason: err };\n            if (_global.document && document.createEvent) {\n                event = document.createEvent('Event');\n                event.initEvent(UNHANDLEDREJECTION, true, true);\n                extend(event, eventData);\n            }\n            else if (_global.CustomEvent) {\n                event = new CustomEvent(UNHANDLEDREJECTION, { detail: eventData });\n                extend(event, eventData);\n            }\n            if (event && _global.dispatchEvent) {\n                dispatchEvent(event);\n                if (!_global.PromiseRejectionEvent && _global.onunhandledrejection)\n                    try {\n                        _global.onunhandledrejection(event);\n                    }\n                    catch (_) { }\n            }\n            if (debug && event && !event.defaultPrevented) {\n                console.warn(`Unhandled rejection: ${err.stack || err}`);\n            }\n        }\n        catch (e) { }\n}\nvar rejection = DexiePromise.reject;\n\nfunction tempTransaction(db, mode, storeNames, fn) {\n    if (!db.idbdb || (!db._state.openComplete && (!PSD.letThrough && !db._vip))) {\n        if (db._state.openComplete) {\n            return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));\n        }\n        if (!db._state.isBeingOpened) {\n            if (!db._options.autoOpen)\n                return rejection(new exceptions.DatabaseClosed());\n            db.open().catch(nop);\n        }\n        return db._state.dbReadyPromise.then(() => tempTransaction(db, mode, storeNames, fn));\n    }\n    else {\n        var trans = db._createTransaction(mode, storeNames, db._dbSchema);\n        try {\n            trans.create();\n        }\n        catch (ex) {\n            return rejection(ex);\n        }\n        return trans._promise(mode, (resolve, reject) => {\n            return newScope(() => {\n                PSD.trans = trans;\n                return fn(resolve, reject, trans);\n            });\n        }).then(result => {\n            return trans._completion.then(() => result);\n        });\n    }\n}\n\nconst DEXIE_VERSION = '3.2.0';\nconst maxString = String.fromCharCode(65535);\nconst minKey = -Infinity;\nconst INVALID_KEY_ARGUMENT = \"Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.\";\nconst STRING_EXPECTED = \"String expected.\";\nconst connections = [];\nconst isIEOrEdge = typeof navigator !== 'undefined' && /(MSIE|Trident|Edge)/.test(navigator.userAgent);\nconst hasIEDeleteObjectStoreBug = isIEOrEdge;\nconst hangsOnDeleteLargeKeyRange = isIEOrEdge;\nconst dexieStackFrameFilter = frame => !/(dexie\\.js|dexie\\.min\\.js)/.test(frame);\nconst DBNAMES_DB = '__dbnames';\nconst READONLY = 'readonly';\nconst READWRITE = 'readwrite';\n\nfunction combine(filter1, filter2) {\n    return filter1 ?\n        filter2 ?\n            function () { return filter1.apply(this, arguments) && filter2.apply(this, arguments); } :\n            filter1 :\n        filter2;\n}\n\nconst AnyRange = {\n    type: 3 ,\n    lower: -Infinity,\n    lowerOpen: false,\n    upper: [[]],\n    upperOpen: false\n};\n\nfunction workaroundForUndefinedPrimKey(keyPath) {\n    return typeof keyPath === \"string\" && !/\\./.test(keyPath)\n        ? (obj) => {\n            if (obj[keyPath] === undefined && (keyPath in obj)) {\n                obj = deepClone(obj);\n                delete obj[keyPath];\n            }\n            return obj;\n        }\n        : (obj) => obj;\n}\n\nclass Table {\n    _trans(mode, fn, writeLocked) {\n        const trans = this._tx || PSD.trans;\n        const tableName = this.name;\n        function checkTableInTransaction(resolve, reject, trans) {\n            if (!trans.schema[tableName])\n                throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n            return fn(trans.idbtrans, trans);\n        }\n        const wasRootExec = beginMicroTickScope();\n        try {\n            return trans && trans.db === this.db ?\n                trans === PSD.trans ?\n                    trans._promise(mode, checkTableInTransaction, writeLocked) :\n                    newScope(() => trans._promise(mode, checkTableInTransaction, writeLocked), { trans: trans, transless: PSD.transless || PSD }) :\n                tempTransaction(this.db, mode, [this.name], checkTableInTransaction);\n        }\n        finally {\n            if (wasRootExec)\n                endMicroTickScope();\n        }\n    }\n    get(keyOrCrit, cb) {\n        if (keyOrCrit && keyOrCrit.constructor === Object)\n            return this.where(keyOrCrit).first(cb);\n        return this._trans('readonly', (trans) => {\n            return this.core.get({ trans, key: keyOrCrit })\n                .then(res => this.hook.reading.fire(res));\n        }).then(cb);\n    }\n    where(indexOrCrit) {\n        if (typeof indexOrCrit === 'string')\n            return new this.db.WhereClause(this, indexOrCrit);\n        if (isArray(indexOrCrit))\n            return new this.db.WhereClause(this, `[${indexOrCrit.join('+')}]`);\n        const keyPaths = keys(indexOrCrit);\n        if (keyPaths.length === 1)\n            return this\n                .where(keyPaths[0])\n                .equals(indexOrCrit[keyPaths[0]]);\n        const compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(ix => ix.compound &&\n            keyPaths.every(keyPath => ix.keyPath.indexOf(keyPath) >= 0) &&\n            ix.keyPath.every(keyPath => keyPaths.indexOf(keyPath) >= 0))[0];\n        if (compoundIndex && this.db._maxKey !== maxString)\n            return this\n                .where(compoundIndex.name)\n                .equals(compoundIndex.keyPath.map(kp => indexOrCrit[kp]));\n        if (!compoundIndex && debug)\n            console.warn(`The query ${JSON.stringify(indexOrCrit)} on ${this.name} would benefit of a ` +\n                `compound index [${keyPaths.join('+')}]`);\n        const { idxByName } = this.schema;\n        const idb = this.db._deps.indexedDB;\n        function equals(a, b) {\n            try {\n                return idb.cmp(a, b) === 0;\n            }\n            catch (e) {\n                return false;\n            }\n        }\n        const [idx, filterFunction] = keyPaths.reduce(([prevIndex, prevFilterFn], keyPath) => {\n            const index = idxByName[keyPath];\n            const value = indexOrCrit[keyPath];\n            return [\n                prevIndex || index,\n                prevIndex || !index ?\n                    combine(prevFilterFn, index && index.multi ?\n                        x => {\n                            const prop = getByKeyPath(x, keyPath);\n                            return isArray(prop) && prop.some(item => equals(value, item));\n                        } : x => equals(value, getByKeyPath(x, keyPath)))\n                    : prevFilterFn\n            ];\n        }, [null, null]);\n        return idx ?\n            this.where(idx.name).equals(indexOrCrit[idx.keyPath])\n                .filter(filterFunction) :\n            compoundIndex ?\n                this.filter(filterFunction) :\n                this.where(keyPaths).equals('');\n    }\n    filter(filterFunction) {\n        return this.toCollection().and(filterFunction);\n    }\n    count(thenShortcut) {\n        return this.toCollection().count(thenShortcut);\n    }\n    offset(offset) {\n        return this.toCollection().offset(offset);\n    }\n    limit(numRows) {\n        return this.toCollection().limit(numRows);\n    }\n    each(callback) {\n        return this.toCollection().each(callback);\n    }\n    toArray(thenShortcut) {\n        return this.toCollection().toArray(thenShortcut);\n    }\n    toCollection() {\n        return new this.db.Collection(new this.db.WhereClause(this));\n    }\n    orderBy(index) {\n        return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ?\n            `[${index.join('+')}]` :\n            index));\n    }\n    reverse() {\n        return this.toCollection().reverse();\n    }\n    mapToClass(constructor) {\n        this.schema.mappedClass = constructor;\n        const readHook = obj => {\n            if (!obj)\n                return obj;\n            const res = Object.create(constructor.prototype);\n            for (var m in obj)\n                if (hasOwn(obj, m))\n                    try {\n                        res[m] = obj[m];\n                    }\n                    catch (_) { }\n            return res;\n        };\n        if (this.schema.readHook) {\n            this.hook.reading.unsubscribe(this.schema.readHook);\n        }\n        this.schema.readHook = readHook;\n        this.hook(\"reading\", readHook);\n        return constructor;\n    }\n    defineClass() {\n        function Class(content) {\n            extend(this, content);\n        }\n        return this.mapToClass(Class);\n    }\n    add(obj, key) {\n        const { auto, keyPath } = this.schema.primKey;\n        let objToAdd = obj;\n        if (keyPath && auto) {\n            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n        }\n        return this._trans('readwrite', trans => {\n            return this.core.mutate({ trans, type: 'add', keys: key != null ? [key] : null, values: [objToAdd] });\n        }).then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult)\n            .then(lastResult => {\n            if (keyPath) {\n                try {\n                    setByKeyPath(obj, keyPath, lastResult);\n                }\n                catch (_) { }\n            }\n            return lastResult;\n        });\n    }\n    update(keyOrObject, modifications) {\n        if (typeof keyOrObject === 'object' && !isArray(keyOrObject)) {\n            const key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);\n            if (key === undefined)\n                return rejection(new exceptions.InvalidArgument(\"Given object does not contain its primary key\"));\n            try {\n                if (typeof modifications !== \"function\") {\n                    keys(modifications).forEach(keyPath => {\n                        setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);\n                    });\n                }\n                else {\n                    modifications(keyOrObject, { value: keyOrObject, primKey: key });\n                }\n            }\n            catch (_a) {\n            }\n            return this.where(\":id\").equals(key).modify(modifications);\n        }\n        else {\n            return this.where(\":id\").equals(keyOrObject).modify(modifications);\n        }\n    }\n    put(obj, key) {\n        const { auto, keyPath } = this.schema.primKey;\n        let objToAdd = obj;\n        if (keyPath && auto) {\n            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n        }\n        return this._trans('readwrite', trans => this.core.mutate({ trans, type: 'put', values: [objToAdd], keys: key != null ? [key] : null }))\n            .then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult)\n            .then(lastResult => {\n            if (keyPath) {\n                try {\n                    setByKeyPath(obj, keyPath, lastResult);\n                }\n                catch (_) { }\n            }\n            return lastResult;\n        });\n    }\n    delete(key) {\n        return this._trans('readwrite', trans => this.core.mutate({ trans, type: 'delete', keys: [key] }))\n            .then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);\n    }\n    clear() {\n        return this._trans('readwrite', trans => this.core.mutate({ trans, type: 'deleteRange', range: AnyRange }))\n            .then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);\n    }\n    bulkGet(keys) {\n        return this._trans('readonly', trans => {\n            return this.core.getMany({\n                keys,\n                trans\n            }).then(result => result.map(res => this.hook.reading.fire(res)));\n        });\n    }\n    bulkAdd(objects, keysOrOptions, options) {\n        const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n        options = options || (keys ? undefined : keysOrOptions);\n        const wantResults = options ? options.allKeys : undefined;\n        return this._trans('readwrite', trans => {\n            const { auto, keyPath } = this.schema.primKey;\n            if (keyPath && keys)\n                throw new exceptions.InvalidArgument(\"bulkAdd(): keys argument invalid on tables with inbound keys\");\n            if (keys && keys.length !== objects.length)\n                throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n            const numObjects = objects.length;\n            let objectsToAdd = keyPath && auto ?\n                objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n                objects;\n            return this.core.mutate({ trans, type: 'add', keys: keys, values: objectsToAdd, wantResults })\n                .then(({ numFailures, results, lastResult, failures }) => {\n                const result = wantResults ? results : lastResult;\n                if (numFailures === 0)\n                    return result;\n                throw new BulkError(`${this.name}.bulkAdd(): ${numFailures} of ${numObjects} operations failed`, failures);\n            });\n        });\n    }\n    bulkPut(objects, keysOrOptions, options) {\n        const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n        options = options || (keys ? undefined : keysOrOptions);\n        const wantResults = options ? options.allKeys : undefined;\n        return this._trans('readwrite', trans => {\n            const { auto, keyPath } = this.schema.primKey;\n            if (keyPath && keys)\n                throw new exceptions.InvalidArgument(\"bulkPut(): keys argument invalid on tables with inbound keys\");\n            if (keys && keys.length !== objects.length)\n                throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n            const numObjects = objects.length;\n            let objectsToPut = keyPath && auto ?\n                objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n                objects;\n            return this.core.mutate({ trans, type: 'put', keys: keys, values: objectsToPut, wantResults })\n                .then(({ numFailures, results, lastResult, failures }) => {\n                const result = wantResults ? results : lastResult;\n                if (numFailures === 0)\n                    return result;\n                throw new BulkError(`${this.name}.bulkPut(): ${numFailures} of ${numObjects} operations failed`, failures);\n            });\n        });\n    }\n    bulkDelete(keys) {\n        const numKeys = keys.length;\n        return this._trans('readwrite', trans => {\n            return this.core.mutate({ trans, type: 'delete', keys: keys });\n        }).then(({ numFailures, lastResult, failures }) => {\n            if (numFailures === 0)\n                return lastResult;\n            throw new BulkError(`${this.name}.bulkDelete(): ${numFailures} of ${numKeys} operations failed`, failures);\n        });\n    }\n}\n\nfunction Events(ctx) {\n    var evs = {};\n    var rv = function (eventName, subscriber) {\n        if (subscriber) {\n            var i = arguments.length, args = new Array(i - 1);\n            while (--i)\n                args[i - 1] = arguments[i];\n            evs[eventName].subscribe.apply(null, args);\n            return ctx;\n        }\n        else if (typeof (eventName) === 'string') {\n            return evs[eventName];\n        }\n    };\n    rv.addEventType = add;\n    for (var i = 1, l = arguments.length; i < l; ++i) {\n        add(arguments[i]);\n    }\n    return rv;\n    function add(eventName, chainFunction, defaultFunction) {\n        if (typeof eventName === 'object')\n            return addConfiguredEvents(eventName);\n        if (!chainFunction)\n            chainFunction = reverseStoppableEventChain;\n        if (!defaultFunction)\n            defaultFunction = nop;\n        var context = {\n            subscribers: [],\n            fire: defaultFunction,\n            subscribe: function (cb) {\n                if (context.subscribers.indexOf(cb) === -1) {\n                    context.subscribers.push(cb);\n                    context.fire = chainFunction(context.fire, cb);\n                }\n            },\n            unsubscribe: function (cb) {\n                context.subscribers = context.subscribers.filter(function (fn) { return fn !== cb; });\n                context.fire = context.subscribers.reduce(chainFunction, defaultFunction);\n            }\n        };\n        evs[eventName] = rv[eventName] = context;\n        return context;\n    }\n    function addConfiguredEvents(cfg) {\n        keys(cfg).forEach(function (eventName) {\n            var args = cfg[eventName];\n            if (isArray(args)) {\n                add(eventName, cfg[eventName][0], cfg[eventName][1]);\n            }\n            else if (args === 'asap') {\n                var context = add(eventName, mirror, function fire() {\n                    var i = arguments.length, args = new Array(i);\n                    while (i--)\n                        args[i] = arguments[i];\n                    context.subscribers.forEach(function (fn) {\n                        asap$1(function fireEvent() {\n                            fn.apply(null, args);\n                        });\n                    });\n                });\n            }\n            else\n                throw new exceptions.InvalidArgument(\"Invalid event config\");\n        });\n    }\n}\n\nfunction makeClassConstructor(prototype, constructor) {\n    derive(constructor).from({ prototype });\n    return constructor;\n}\n\nfunction createTableConstructor(db) {\n    return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {\n        this.db = db;\n        this._tx = trans;\n        this.name = name;\n        this.schema = tableSchema;\n        this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {\n            \"creating\": [hookCreatingChain, nop],\n            \"reading\": [pureFunctionChain, mirror],\n            \"updating\": [hookUpdatingChain, nop],\n            \"deleting\": [hookDeletingChain, nop]\n        });\n    });\n}\n\nfunction isPlainKeyRange(ctx, ignoreLimitFilter) {\n    return !(ctx.filter || ctx.algorithm || ctx.or) &&\n        (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);\n}\nfunction addFilter(ctx, fn) {\n    ctx.filter = combine(ctx.filter, fn);\n}\nfunction addReplayFilter(ctx, factory, isLimitFilter) {\n    var curr = ctx.replayFilter;\n    ctx.replayFilter = curr ? () => combine(curr(), factory()) : factory;\n    ctx.justLimit = isLimitFilter && !curr;\n}\nfunction addMatchFilter(ctx, fn) {\n    ctx.isMatch = combine(ctx.isMatch, fn);\n}\nfunction getIndexOrStore(ctx, coreSchema) {\n    if (ctx.isPrimKey)\n        return coreSchema.primaryKey;\n    const index = coreSchema.getIndexByKeyPath(ctx.index);\n    if (!index)\n        throw new exceptions.Schema(\"KeyPath \" + ctx.index + \" on object store \" + coreSchema.name + \" is not indexed\");\n    return index;\n}\nfunction openCursor(ctx, coreTable, trans) {\n    const index = getIndexOrStore(ctx, coreTable.schema);\n    return coreTable.openCursor({\n        trans,\n        values: !ctx.keysOnly,\n        reverse: ctx.dir === 'prev',\n        unique: !!ctx.unique,\n        query: {\n            index,\n            range: ctx.range\n        }\n    });\n}\nfunction iter(ctx, fn, coreTrans, coreTable) {\n    const filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;\n    if (!ctx.or) {\n        return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);\n    }\n    else {\n        const set = {};\n        const union = (item, cursor, advance) => {\n            if (!filter || filter(cursor, advance, result => cursor.stop(result), err => cursor.fail(err))) {\n                var primaryKey = cursor.primaryKey;\n                var key = '' + primaryKey;\n                if (key === '[object ArrayBuffer]')\n                    key = '' + new Uint8Array(primaryKey);\n                if (!hasOwn(set, key)) {\n                    set[key] = true;\n                    fn(item, cursor, advance);\n                }\n            }\n        };\n        return Promise.all([\n            ctx.or._iterate(union, coreTrans),\n            iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)\n        ]);\n    }\n}\nfunction iterate(cursorPromise, filter, fn, valueMapper) {\n    var mappedFn = valueMapper ? (x, c, a) => fn(valueMapper(x), c, a) : fn;\n    var wrappedFn = wrap(mappedFn);\n    return cursorPromise.then(cursor => {\n        if (cursor) {\n            return cursor.start(() => {\n                var c = () => cursor.continue();\n                if (!filter || filter(cursor, advancer => c = advancer, val => { cursor.stop(val); c = nop; }, e => { cursor.fail(e); c = nop; }))\n                    wrappedFn(cursor.value, cursor, advancer => c = advancer);\n                c();\n            });\n        }\n    });\n}\n\nfunction cmp(a, b) {\n    try {\n        const ta = type(a);\n        const tb = type(b);\n        if (ta !== tb) {\n            if (ta === 'Array')\n                return 1;\n            if (tb === 'Array')\n                return -1;\n            if (ta === 'binary')\n                return 1;\n            if (tb === 'binary')\n                return -1;\n            if (ta === 'string')\n                return 1;\n            if (tb === 'string')\n                return -1;\n            if (ta === 'Date')\n                return 1;\n            if (tb !== 'Date')\n                return NaN;\n            return -1;\n        }\n        switch (ta) {\n            case 'number':\n            case 'Date':\n            case 'string':\n                return a > b ? 1 : a < b ? -1 : 0;\n            case 'binary': {\n                return compareUint8Arrays(getUint8Array(a), getUint8Array(b));\n            }\n            case 'Array':\n                return compareArrays(a, b);\n        }\n    }\n    catch (_a) { }\n    return NaN;\n}\nfunction compareArrays(a, b) {\n    const al = a.length;\n    const bl = b.length;\n    const l = al < bl ? al : bl;\n    for (let i = 0; i < l; ++i) {\n        const res = cmp(a[i], b[i]);\n        if (res !== 0)\n            return res;\n    }\n    return al === bl ? 0 : al < bl ? -1 : 1;\n}\nfunction compareUint8Arrays(a, b) {\n    const al = a.length;\n    const bl = b.length;\n    const l = al < bl ? al : bl;\n    for (let i = 0; i < l; ++i) {\n        if (a[i] !== b[i])\n            return a[i] < b[i] ? -1 : 1;\n    }\n    return al === bl ? 0 : al < bl ? -1 : 1;\n}\nfunction type(x) {\n    const t = typeof x;\n    if (t !== 'object')\n        return t;\n    if (ArrayBuffer.isView(x))\n        return 'binary';\n    const tsTag = toStringTag(x);\n    return tsTag === 'ArrayBuffer' ? 'binary' : tsTag;\n}\nfunction getUint8Array(a) {\n    if (a instanceof Uint8Array)\n        return a;\n    if (ArrayBuffer.isView(a))\n        return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n    return new Uint8Array(a);\n}\n\nclass Collection {\n    _read(fn, cb) {\n        var ctx = this._ctx;\n        return ctx.error ?\n            ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n            ctx.table._trans('readonly', fn).then(cb);\n    }\n    _write(fn) {\n        var ctx = this._ctx;\n        return ctx.error ?\n            ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n            ctx.table._trans('readwrite', fn, \"locked\");\n    }\n    _addAlgorithm(fn) {\n        var ctx = this._ctx;\n        ctx.algorithm = combine(ctx.algorithm, fn);\n    }\n    _iterate(fn, coreTrans) {\n        return iter(this._ctx, fn, coreTrans, this._ctx.table.core);\n    }\n    clone(props) {\n        var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);\n        if (props)\n            extend(ctx, props);\n        rv._ctx = ctx;\n        return rv;\n    }\n    raw() {\n        this._ctx.valueMapper = null;\n        return this;\n    }\n    each(fn) {\n        var ctx = this._ctx;\n        return this._read(trans => iter(ctx, fn, trans, ctx.table.core));\n    }\n    count(cb) {\n        return this._read(trans => {\n            const ctx = this._ctx;\n            const coreTable = ctx.table.core;\n            if (isPlainKeyRange(ctx, true)) {\n                return coreTable.count({\n                    trans,\n                    query: {\n                        index: getIndexOrStore(ctx, coreTable.schema),\n                        range: ctx.range\n                    }\n                }).then(count => Math.min(count, ctx.limit));\n            }\n            else {\n                var count = 0;\n                return iter(ctx, () => { ++count; return false; }, trans, coreTable)\n                    .then(() => count);\n            }\n        }).then(cb);\n    }\n    sortBy(keyPath, cb) {\n        const parts = keyPath.split('.').reverse(), lastPart = parts[0], lastIndex = parts.length - 1;\n        function getval(obj, i) {\n            if (i)\n                return getval(obj[parts[i]], i - 1);\n            return obj[lastPart];\n        }\n        var order = this._ctx.dir === \"next\" ? 1 : -1;\n        function sorter(a, b) {\n            var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);\n            return aVal < bVal ? -order : aVal > bVal ? order : 0;\n        }\n        return this.toArray(function (a) {\n            return a.sort(sorter);\n        }).then(cb);\n    }\n    toArray(cb) {\n        return this._read(trans => {\n            var ctx = this._ctx;\n            if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n                const { valueMapper } = ctx;\n                const index = getIndexOrStore(ctx, ctx.table.core.schema);\n                return ctx.table.core.query({\n                    trans,\n                    limit: ctx.limit,\n                    values: true,\n                    query: {\n                        index,\n                        range: ctx.range\n                    }\n                }).then(({ result }) => valueMapper ? result.map(valueMapper) : result);\n            }\n            else {\n                const a = [];\n                return iter(ctx, item => a.push(item), trans, ctx.table.core).then(() => a);\n            }\n        }, cb);\n    }\n    offset(offset) {\n        var ctx = this._ctx;\n        if (offset <= 0)\n            return this;\n        ctx.offset += offset;\n        if (isPlainKeyRange(ctx)) {\n            addReplayFilter(ctx, () => {\n                var offsetLeft = offset;\n                return (cursor, advance) => {\n                    if (offsetLeft === 0)\n                        return true;\n                    if (offsetLeft === 1) {\n                        --offsetLeft;\n                        return false;\n                    }\n                    advance(() => {\n                        cursor.advance(offsetLeft);\n                        offsetLeft = 0;\n                    });\n                    return false;\n                };\n            });\n        }\n        else {\n            addReplayFilter(ctx, () => {\n                var offsetLeft = offset;\n                return () => (--offsetLeft < 0);\n            });\n        }\n        return this;\n    }\n    limit(numRows) {\n        this._ctx.limit = Math.min(this._ctx.limit, numRows);\n        addReplayFilter(this._ctx, () => {\n            var rowsLeft = numRows;\n            return function (cursor, advance, resolve) {\n                if (--rowsLeft <= 0)\n                    advance(resolve);\n                return rowsLeft >= 0;\n            };\n        }, true);\n        return this;\n    }\n    until(filterFunction, bIncludeStopEntry) {\n        addFilter(this._ctx, function (cursor, advance, resolve) {\n            if (filterFunction(cursor.value)) {\n                advance(resolve);\n                return bIncludeStopEntry;\n            }\n            else {\n                return true;\n            }\n        });\n        return this;\n    }\n    first(cb) {\n        return this.limit(1).toArray(function (a) { return a[0]; }).then(cb);\n    }\n    last(cb) {\n        return this.reverse().first(cb);\n    }\n    filter(filterFunction) {\n        addFilter(this._ctx, function (cursor) {\n            return filterFunction(cursor.value);\n        });\n        addMatchFilter(this._ctx, filterFunction);\n        return this;\n    }\n    and(filter) {\n        return this.filter(filter);\n    }\n    or(indexName) {\n        return new this.db.WhereClause(this._ctx.table, indexName, this);\n    }\n    reverse() {\n        this._ctx.dir = (this._ctx.dir === \"prev\" ? \"next\" : \"prev\");\n        if (this._ondirectionchange)\n            this._ondirectionchange(this._ctx.dir);\n        return this;\n    }\n    desc() {\n        return this.reverse();\n    }\n    eachKey(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        return this.each(function (val, cursor) { cb(cursor.key, cursor); });\n    }\n    eachUniqueKey(cb) {\n        this._ctx.unique = \"unique\";\n        return this.eachKey(cb);\n    }\n    eachPrimaryKey(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        return this.each(function (val, cursor) { cb(cursor.primaryKey, cursor); });\n    }\n    keys(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        var a = [];\n        return this.each(function (item, cursor) {\n            a.push(cursor.key);\n        }).then(function () {\n            return a;\n        }).then(cb);\n    }\n    primaryKeys(cb) {\n        var ctx = this._ctx;\n        if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n            return this._read(trans => {\n                var index = getIndexOrStore(ctx, ctx.table.core.schema);\n                return ctx.table.core.query({\n                    trans,\n                    values: false,\n                    limit: ctx.limit,\n                    query: {\n                        index,\n                        range: ctx.range\n                    }\n                });\n            }).then(({ result }) => result).then(cb);\n        }\n        ctx.keysOnly = !ctx.isMatch;\n        var a = [];\n        return this.each(function (item, cursor) {\n            a.push(cursor.primaryKey);\n        }).then(function () {\n            return a;\n        }).then(cb);\n    }\n    uniqueKeys(cb) {\n        this._ctx.unique = \"unique\";\n        return this.keys(cb);\n    }\n    firstKey(cb) {\n        return this.limit(1).keys(function (a) { return a[0]; }).then(cb);\n    }\n    lastKey(cb) {\n        return this.reverse().firstKey(cb);\n    }\n    distinct() {\n        var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];\n        if (!idx || !idx.multi)\n            return this;\n        var set = {};\n        addFilter(this._ctx, function (cursor) {\n            var strKey = cursor.primaryKey.toString();\n            var found = hasOwn(set, strKey);\n            set[strKey] = true;\n            return !found;\n        });\n        return this;\n    }\n    modify(changes) {\n        var ctx = this._ctx;\n        return this._write(trans => {\n            var modifyer;\n            if (typeof changes === 'function') {\n                modifyer = changes;\n            }\n            else {\n                var keyPaths = keys(changes);\n                var numKeys = keyPaths.length;\n                modifyer = function (item) {\n                    var anythingModified = false;\n                    for (var i = 0; i < numKeys; ++i) {\n                        var keyPath = keyPaths[i], val = changes[keyPath];\n                        if (getByKeyPath(item, keyPath) !== val) {\n                            setByKeyPath(item, keyPath, val);\n                            anythingModified = true;\n                        }\n                    }\n                    return anythingModified;\n                };\n            }\n            const coreTable = ctx.table.core;\n            const { outbound, extractKey } = coreTable.schema.primaryKey;\n            const limit = this.db._options.modifyChunkSize || 200;\n            const totalFailures = [];\n            let successCount = 0;\n            const failedKeys = [];\n            const applyMutateResult = (expectedCount, res) => {\n                const { failures, numFailures } = res;\n                successCount += expectedCount - numFailures;\n                for (let pos of keys(failures)) {\n                    totalFailures.push(failures[pos]);\n                }\n            };\n            return this.clone().primaryKeys().then(keys => {\n                const nextChunk = (offset) => {\n                    const count = Math.min(limit, keys.length - offset);\n                    return coreTable.getMany({\n                        trans,\n                        keys: keys.slice(offset, offset + count),\n                        cache: \"immutable\"\n                    }).then(values => {\n                        const addValues = [];\n                        const putValues = [];\n                        const putKeys = outbound ? [] : null;\n                        const deleteKeys = [];\n                        for (let i = 0; i < count; ++i) {\n                            const origValue = values[i];\n                            const ctx = {\n                                value: deepClone(origValue),\n                                primKey: keys[offset + i]\n                            };\n                            if (modifyer.call(ctx, ctx.value, ctx) !== false) {\n                                if (ctx.value == null) {\n                                    deleteKeys.push(keys[offset + i]);\n                                }\n                                else if (!outbound && cmp(extractKey(origValue), extractKey(ctx.value)) !== 0) {\n                                    deleteKeys.push(keys[offset + i]);\n                                    addValues.push(ctx.value);\n                                }\n                                else {\n                                    putValues.push(ctx.value);\n                                    if (outbound)\n                                        putKeys.push(keys[offset + i]);\n                                }\n                            }\n                        }\n                        const criteria = isPlainKeyRange(ctx) &&\n                            ctx.limit === Infinity &&\n                            (typeof changes !== 'function' || changes === deleteCallback) && {\n                            index: ctx.index,\n                            range: ctx.range\n                        };\n                        return Promise.resolve(addValues.length > 0 &&\n                            coreTable.mutate({ trans, type: 'add', values: addValues })\n                                .then(res => {\n                                for (let pos in res.failures) {\n                                    deleteKeys.splice(parseInt(pos), 1);\n                                }\n                                applyMutateResult(addValues.length, res);\n                            })).then(() => (putValues.length > 0 || (criteria && typeof changes === 'object')) &&\n                            coreTable.mutate({\n                                trans,\n                                type: 'put',\n                                keys: putKeys,\n                                values: putValues,\n                                criteria,\n                                changeSpec: typeof changes !== 'function'\n                                    && changes\n                            }).then(res => applyMutateResult(putValues.length, res))).then(() => (deleteKeys.length > 0 || (criteria && changes === deleteCallback)) &&\n                            coreTable.mutate({\n                                trans,\n                                type: 'delete',\n                                keys: deleteKeys,\n                                criteria\n                            }).then(res => applyMutateResult(deleteKeys.length, res))).then(() => {\n                            return keys.length > offset + count && nextChunk(offset + limit);\n                        });\n                    });\n                };\n                return nextChunk(0).then(() => {\n                    if (totalFailures.length > 0)\n                        throw new ModifyError(\"Error modifying one or more objects\", totalFailures, successCount, failedKeys);\n                    return keys.length;\n                });\n            });\n        });\n    }\n    delete() {\n        var ctx = this._ctx, range = ctx.range;\n        if (isPlainKeyRange(ctx) &&\n            ((ctx.isPrimKey && !hangsOnDeleteLargeKeyRange) || range.type === 3 ))\n         {\n            return this._write(trans => {\n                const { primaryKey } = ctx.table.core.schema;\n                const coreRange = range;\n                return ctx.table.core.count({ trans, query: { index: primaryKey, range: coreRange } }).then(count => {\n                    return ctx.table.core.mutate({ trans, type: 'deleteRange', range: coreRange })\n                        .then(({ failures, lastResult, results, numFailures }) => {\n                        if (numFailures)\n                            throw new ModifyError(\"Could not delete some values\", Object.keys(failures).map(pos => failures[pos]), count - numFailures);\n                        return count - numFailures;\n                    });\n                });\n            });\n        }\n        return this.modify(deleteCallback);\n    }\n}\nconst deleteCallback = (value, ctx) => ctx.value = null;\n\nfunction createCollectionConstructor(db) {\n    return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {\n        this.db = db;\n        let keyRange = AnyRange, error = null;\n        if (keyRangeGenerator)\n            try {\n                keyRange = keyRangeGenerator();\n            }\n            catch (ex) {\n                error = ex;\n            }\n        const whereCtx = whereClause._ctx;\n        const table = whereCtx.table;\n        const readingHook = table.hook.reading.fire;\n        this._ctx = {\n            table: table,\n            index: whereCtx.index,\n            isPrimKey: (!whereCtx.index || (table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name)),\n            range: keyRange,\n            keysOnly: false,\n            dir: \"next\",\n            unique: \"\",\n            algorithm: null,\n            filter: null,\n            replayFilter: null,\n            justLimit: true,\n            isMatch: null,\n            offset: 0,\n            limit: Infinity,\n            error: error,\n            or: whereCtx.or,\n            valueMapper: readingHook !== mirror ? readingHook : null\n        };\n    });\n}\n\nfunction simpleCompare(a, b) {\n    return a < b ? -1 : a === b ? 0 : 1;\n}\nfunction simpleCompareReverse(a, b) {\n    return a > b ? -1 : a === b ? 0 : 1;\n}\n\nfunction fail(collectionOrWhereClause, err, T) {\n    var collection = collectionOrWhereClause instanceof WhereClause ?\n        new collectionOrWhereClause.Collection(collectionOrWhereClause) :\n        collectionOrWhereClause;\n    collection._ctx.error = T ? new T(err) : new TypeError(err);\n    return collection;\n}\nfunction emptyCollection(whereClause) {\n    return new whereClause.Collection(whereClause, () => rangeEqual(\"\")).limit(0);\n}\nfunction upperFactory(dir) {\n    return dir === \"next\" ?\n        (s) => s.toUpperCase() :\n        (s) => s.toLowerCase();\n}\nfunction lowerFactory(dir) {\n    return dir === \"next\" ?\n        (s) => s.toLowerCase() :\n        (s) => s.toUpperCase();\n}\nfunction nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {\n    var length = Math.min(key.length, lowerNeedle.length);\n    var llp = -1;\n    for (var i = 0; i < length; ++i) {\n        var lwrKeyChar = lowerKey[i];\n        if (lwrKeyChar !== lowerNeedle[i]) {\n            if (cmp(key[i], upperNeedle[i]) < 0)\n                return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);\n            if (cmp(key[i], lowerNeedle[i]) < 0)\n                return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);\n            if (llp >= 0)\n                return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);\n            return null;\n        }\n        if (cmp(key[i], lwrKeyChar) < 0)\n            llp = i;\n    }\n    if (length < lowerNeedle.length && dir === \"next\")\n        return key + upperNeedle.substr(key.length);\n    if (length < key.length && dir === \"prev\")\n        return key.substr(0, upperNeedle.length);\n    return (llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1));\n}\nfunction addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {\n    var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;\n    if (!needles.every(s => typeof s === 'string')) {\n        return fail(whereClause, STRING_EXPECTED);\n    }\n    function initDirection(dir) {\n        upper = upperFactory(dir);\n        lower = lowerFactory(dir);\n        compare = (dir === \"next\" ? simpleCompare : simpleCompareReverse);\n        var needleBounds = needles.map(function (needle) {\n            return { lower: lower(needle), upper: upper(needle) };\n        }).sort(function (a, b) {\n            return compare(a.lower, b.lower);\n        });\n        upperNeedles = needleBounds.map(function (nb) { return nb.upper; });\n        lowerNeedles = needleBounds.map(function (nb) { return nb.lower; });\n        direction = dir;\n        nextKeySuffix = (dir === \"next\" ? \"\" : suffix);\n    }\n    initDirection(\"next\");\n    var c = new whereClause.Collection(whereClause, () => createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix));\n    c._ondirectionchange = function (direction) {\n        initDirection(direction);\n    };\n    var firstPossibleNeedle = 0;\n    c._addAlgorithm(function (cursor, advance, resolve) {\n        var key = cursor.key;\n        if (typeof key !== 'string')\n            return false;\n        var lowerKey = lower(key);\n        if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {\n            return true;\n        }\n        else {\n            var lowestPossibleCasing = null;\n            for (var i = firstPossibleNeedle; i < needlesLen; ++i) {\n                var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);\n                if (casing === null && lowestPossibleCasing === null)\n                    firstPossibleNeedle = i + 1;\n                else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {\n                    lowestPossibleCasing = casing;\n                }\n            }\n            if (lowestPossibleCasing !== null) {\n                advance(function () { cursor.continue(lowestPossibleCasing + nextKeySuffix); });\n            }\n            else {\n                advance(resolve);\n            }\n            return false;\n        }\n    });\n    return c;\n}\nfunction createRange(lower, upper, lowerOpen, upperOpen) {\n    return {\n        type: 2 ,\n        lower,\n        upper,\n        lowerOpen,\n        upperOpen\n    };\n}\nfunction rangeEqual(value) {\n    return {\n        type: 1 ,\n        lower: value,\n        upper: value\n    };\n}\n\nclass WhereClause {\n    get Collection() {\n        return this._ctx.table.db.Collection;\n    }\n    between(lower, upper, includeLower, includeUpper) {\n        includeLower = includeLower !== false;\n        includeUpper = includeUpper === true;\n        try {\n            if ((this._cmp(lower, upper) > 0) ||\n                (this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)))\n                return emptyCollection(this);\n            return new this.Collection(this, () => createRange(lower, upper, !includeLower, !includeUpper));\n        }\n        catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n    }\n    equals(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => rangeEqual(value));\n    }\n    above(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(value, undefined, true));\n    }\n    aboveOrEqual(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(value, undefined, false));\n    }\n    below(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(undefined, value, false, true));\n    }\n    belowOrEqual(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(undefined, value));\n    }\n    startsWith(str) {\n        if (typeof str !== 'string')\n            return fail(this, STRING_EXPECTED);\n        return this.between(str, str + maxString, true, true);\n    }\n    startsWithIgnoreCase(str) {\n        if (str === \"\")\n            return this.startsWith(str);\n        return addIgnoreCaseAlgorithm(this, (x, a) => x.indexOf(a[0]) === 0, [str], maxString);\n    }\n    equalsIgnoreCase(str) {\n        return addIgnoreCaseAlgorithm(this, (x, a) => x === a[0], [str], \"\");\n    }\n    anyOfIgnoreCase() {\n        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0)\n            return emptyCollection(this);\n        return addIgnoreCaseAlgorithm(this, (x, a) => a.indexOf(x) !== -1, set, \"\");\n    }\n    startsWithAnyOfIgnoreCase() {\n        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0)\n            return emptyCollection(this);\n        return addIgnoreCaseAlgorithm(this, (x, a) => a.some(n => x.indexOf(n) === 0), set, maxString);\n    }\n    anyOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        let compare = this._cmp;\n        try {\n            set.sort(compare);\n        }\n        catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        if (set.length === 0)\n            return emptyCollection(this);\n        const c = new this.Collection(this, () => createRange(set[0], set[set.length - 1]));\n        c._ondirectionchange = direction => {\n            compare = (direction === \"next\" ?\n                this._ascending :\n                this._descending);\n            set.sort(compare);\n        };\n        let i = 0;\n        c._addAlgorithm((cursor, advance, resolve) => {\n            const key = cursor.key;\n            while (compare(key, set[i]) > 0) {\n                ++i;\n                if (i === set.length) {\n                    advance(resolve);\n                    return false;\n                }\n            }\n            if (compare(key, set[i]) === 0) {\n                return true;\n            }\n            else {\n                advance(() => { cursor.continue(set[i]); });\n                return false;\n            }\n        });\n        return c;\n    }\n    notEqual(value) {\n        return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });\n    }\n    noneOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0)\n            return new this.Collection(this);\n        try {\n            set.sort(this._ascending);\n        }\n        catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        const ranges = set.reduce((res, val) => res ?\n            res.concat([[res[res.length - 1][1], val]]) :\n            [[minKey, val]], null);\n        ranges.push([set[set.length - 1], this.db._maxKey]);\n        return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });\n    }\n    inAnyRange(ranges, options) {\n        const cmp = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;\n        if (ranges.length === 0)\n            return emptyCollection(this);\n        if (!ranges.every(range => range[0] !== undefined &&\n            range[1] !== undefined &&\n            ascending(range[0], range[1]) <= 0)) {\n            return fail(this, \"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\", exceptions.InvalidArgument);\n        }\n        const includeLowers = !options || options.includeLowers !== false;\n        const includeUppers = options && options.includeUppers === true;\n        function addRange(ranges, newRange) {\n            let i = 0, l = ranges.length;\n            for (; i < l; ++i) {\n                const range = ranges[i];\n                if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {\n                    range[0] = min(range[0], newRange[0]);\n                    range[1] = max(range[1], newRange[1]);\n                    break;\n                }\n            }\n            if (i === l)\n                ranges.push(newRange);\n            return ranges;\n        }\n        let sortDirection = ascending;\n        function rangeSorter(a, b) { return sortDirection(a[0], b[0]); }\n        let set;\n        try {\n            set = ranges.reduce(addRange, []);\n            set.sort(rangeSorter);\n        }\n        catch (ex) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        let rangePos = 0;\n        const keyIsBeyondCurrentEntry = includeUppers ?\n            key => ascending(key, set[rangePos][1]) > 0 :\n            key => ascending(key, set[rangePos][1]) >= 0;\n        const keyIsBeforeCurrentEntry = includeLowers ?\n            key => descending(key, set[rangePos][0]) > 0 :\n            key => descending(key, set[rangePos][0]) >= 0;\n        function keyWithinCurrentRange(key) {\n            return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);\n        }\n        let checkKey = keyIsBeyondCurrentEntry;\n        const c = new this.Collection(this, () => createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers));\n        c._ondirectionchange = direction => {\n            if (direction === \"next\") {\n                checkKey = keyIsBeyondCurrentEntry;\n                sortDirection = ascending;\n            }\n            else {\n                checkKey = keyIsBeforeCurrentEntry;\n                sortDirection = descending;\n            }\n            set.sort(rangeSorter);\n        };\n        c._addAlgorithm((cursor, advance, resolve) => {\n            var key = cursor.key;\n            while (checkKey(key)) {\n                ++rangePos;\n                if (rangePos === set.length) {\n                    advance(resolve);\n                    return false;\n                }\n            }\n            if (keyWithinCurrentRange(key)) {\n                return true;\n            }\n            else if (this._cmp(key, set[rangePos][1]) === 0 || this._cmp(key, set[rangePos][0]) === 0) {\n                return false;\n            }\n            else {\n                advance(() => {\n                    if (sortDirection === ascending)\n                        cursor.continue(set[rangePos][0]);\n                    else\n                        cursor.continue(set[rangePos][1]);\n                });\n                return false;\n            }\n        });\n        return c;\n    }\n    startsWithAnyOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (!set.every(s => typeof s === 'string')) {\n            return fail(this, \"startsWithAnyOf() only works with strings\");\n        }\n        if (set.length === 0)\n            return emptyCollection(this);\n        return this.inAnyRange(set.map((str) => [str, str + maxString]));\n    }\n}\n\nfunction createWhereClauseConstructor(db) {\n    return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {\n        this.db = db;\n        this._ctx = {\n            table: table,\n            index: index === \":id\" ? null : index,\n            or: orCollection\n        };\n        const indexedDB = db._deps.indexedDB;\n        if (!indexedDB)\n            throw new exceptions.MissingAPI();\n        this._cmp = this._ascending = indexedDB.cmp.bind(indexedDB);\n        this._descending = (a, b) => indexedDB.cmp(b, a);\n        this._max = (a, b) => indexedDB.cmp(a, b) > 0 ? a : b;\n        this._min = (a, b) => indexedDB.cmp(a, b) < 0 ? a : b;\n        this._IDBKeyRange = db._deps.IDBKeyRange;\n    });\n}\n\nfunction eventRejectHandler(reject) {\n    return wrap(function (event) {\n        preventDefault(event);\n        reject(event.target.error);\n        return false;\n    });\n}\nfunction preventDefault(event) {\n    if (event.stopPropagation)\n        event.stopPropagation();\n    if (event.preventDefault)\n        event.preventDefault();\n}\n\nconst DEXIE_STORAGE_MUTATED_EVENT_NAME = 'storagemutated';\nconst STORAGE_MUTATED_DOM_EVENT_NAME = 'x-storagemutated-1';\nconst globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);\n\nclass Transaction {\n    _lock() {\n        assert(!PSD.global);\n        ++this._reculock;\n        if (this._reculock === 1 && !PSD.global)\n            PSD.lockOwnerFor = this;\n        return this;\n    }\n    _unlock() {\n        assert(!PSD.global);\n        if (--this._reculock === 0) {\n            if (!PSD.global)\n                PSD.lockOwnerFor = null;\n            while (this._blockedFuncs.length > 0 && !this._locked()) {\n                var fnAndPSD = this._blockedFuncs.shift();\n                try {\n                    usePSD(fnAndPSD[1], fnAndPSD[0]);\n                }\n                catch (e) { }\n            }\n        }\n        return this;\n    }\n    _locked() {\n        return this._reculock && PSD.lockOwnerFor !== this;\n    }\n    create(idbtrans) {\n        if (!this.mode)\n            return this;\n        const idbdb = this.db.idbdb;\n        const dbOpenError = this.db._state.dbOpenError;\n        assert(!this.idbtrans);\n        if (!idbtrans && !idbdb) {\n            switch (dbOpenError && dbOpenError.name) {\n                case \"DatabaseClosedError\":\n                    throw new exceptions.DatabaseClosed(dbOpenError);\n                case \"MissingAPIError\":\n                    throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);\n                default:\n                    throw new exceptions.OpenFailed(dbOpenError);\n            }\n        }\n        if (!this.active)\n            throw new exceptions.TransactionInactive();\n        assert(this._completion._state === null);\n        idbtrans = this.idbtrans = idbtrans ||\n            (this.db.core\n                ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })\n                : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));\n        idbtrans.onerror = wrap(ev => {\n            preventDefault(ev);\n            this._reject(idbtrans.error);\n        });\n        idbtrans.onabort = wrap(ev => {\n            preventDefault(ev);\n            this.active && this._reject(new exceptions.Abort(idbtrans.error));\n            this.active = false;\n            this.on(\"abort\").fire(ev);\n        });\n        idbtrans.oncomplete = wrap(() => {\n            this.active = false;\n            this._resolve();\n            if ('mutatedParts' in idbtrans) {\n                globalEvents.storagemutated.fire(idbtrans[\"mutatedParts\"]);\n            }\n        });\n        return this;\n    }\n    _promise(mode, fn, bWriteLock) {\n        if (mode === 'readwrite' && this.mode !== 'readwrite')\n            return rejection(new exceptions.ReadOnly(\"Transaction is readonly\"));\n        if (!this.active)\n            return rejection(new exceptions.TransactionInactive());\n        if (this._locked()) {\n            return new DexiePromise((resolve, reject) => {\n                this._blockedFuncs.push([() => {\n                        this._promise(mode, fn, bWriteLock).then(resolve, reject);\n                    }, PSD]);\n            });\n        }\n        else if (bWriteLock) {\n            return newScope(() => {\n                var p = new DexiePromise((resolve, reject) => {\n                    this._lock();\n                    const rv = fn(resolve, reject, this);\n                    if (rv && rv.then)\n                        rv.then(resolve, reject);\n                });\n                p.finally(() => this._unlock());\n                p._lib = true;\n                return p;\n            });\n        }\n        else {\n            var p = new DexiePromise((resolve, reject) => {\n                var rv = fn(resolve, reject, this);\n                if (rv && rv.then)\n                    rv.then(resolve, reject);\n            });\n            p._lib = true;\n            return p;\n        }\n    }\n    _root() {\n        return this.parent ? this.parent._root() : this;\n    }\n    waitFor(promiseLike) {\n        var root = this._root();\n        const promise = DexiePromise.resolve(promiseLike);\n        if (root._waitingFor) {\n            root._waitingFor = root._waitingFor.then(() => promise);\n        }\n        else {\n            root._waitingFor = promise;\n            root._waitingQueue = [];\n            var store = root.idbtrans.objectStore(root.storeNames[0]);\n            (function spin() {\n                ++root._spinCount;\n                while (root._waitingQueue.length)\n                    (root._waitingQueue.shift())();\n                if (root._waitingFor)\n                    store.get(-Infinity).onsuccess = spin;\n            }());\n        }\n        var currentWaitPromise = root._waitingFor;\n        return new DexiePromise((resolve, reject) => {\n            promise.then(res => root._waitingQueue.push(wrap(resolve.bind(null, res))), err => root._waitingQueue.push(wrap(reject.bind(null, err)))).finally(() => {\n                if (root._waitingFor === currentWaitPromise) {\n                    root._waitingFor = null;\n                }\n            });\n        });\n    }\n    abort() {\n        if (this.active) {\n            this.active = false;\n            if (this.idbtrans)\n                this.idbtrans.abort();\n            this._reject(new exceptions.Abort());\n        }\n    }\n    table(tableName) {\n        const memoizedTables = (this._memoizedTables || (this._memoizedTables = {}));\n        if (hasOwn(memoizedTables, tableName))\n            return memoizedTables[tableName];\n        const tableSchema = this.schema[tableName];\n        if (!tableSchema) {\n            throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n        }\n        const transactionBoundTable = new this.db.Table(tableName, tableSchema, this);\n        transactionBoundTable.core = this.db.core.table(tableName);\n        memoizedTables[tableName] = transactionBoundTable;\n        return transactionBoundTable;\n    }\n}\n\nfunction createTransactionConstructor(db) {\n    return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {\n        this.db = db;\n        this.mode = mode;\n        this.storeNames = storeNames;\n        this.schema = dbschema;\n        this.chromeTransactionDurability = chromeTransactionDurability;\n        this.idbtrans = null;\n        this.on = Events(this, \"complete\", \"error\", \"abort\");\n        this.parent = parent || null;\n        this.active = true;\n        this._reculock = 0;\n        this._blockedFuncs = [];\n        this._resolve = null;\n        this._reject = null;\n        this._waitingFor = null;\n        this._waitingQueue = null;\n        this._spinCount = 0;\n        this._completion = new DexiePromise((resolve, reject) => {\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n        this._completion.then(() => {\n            this.active = false;\n            this.on.complete.fire();\n        }, e => {\n            var wasActive = this.active;\n            this.active = false;\n            this.on.error.fire(e);\n            this.parent ?\n                this.parent._reject(e) :\n                wasActive && this.idbtrans && this.idbtrans.abort();\n            return rejection(e);\n        });\n    });\n}\n\nfunction createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {\n    return {\n        name,\n        keyPath,\n        unique,\n        multi,\n        auto,\n        compound,\n        src: (unique && !isPrimKey ? '&' : '') + (multi ? '*' : '') + (auto ? \"++\" : \"\") + nameFromKeyPath(keyPath)\n    };\n}\nfunction nameFromKeyPath(keyPath) {\n    return typeof keyPath === 'string' ?\n        keyPath :\n        keyPath ? ('[' + [].join.call(keyPath, '+') + ']') : \"\";\n}\n\nfunction createTableSchema(name, primKey, indexes) {\n    return {\n        name,\n        primKey,\n        indexes,\n        mappedClass: null,\n        idxByName: arrayToObject(indexes, index => [index.name, index])\n    };\n}\n\nfunction safariMultiStoreFix(storeNames) {\n    return storeNames.length === 1 ? storeNames[0] : storeNames;\n}\nlet getMaxKey = (IdbKeyRange) => {\n    try {\n        IdbKeyRange.only([[]]);\n        getMaxKey = () => [[]];\n        return [[]];\n    }\n    catch (e) {\n        getMaxKey = () => maxString;\n        return maxString;\n    }\n};\n\nfunction getKeyExtractor(keyPath) {\n    if (keyPath == null) {\n        return () => undefined;\n    }\n    else if (typeof keyPath === 'string') {\n        return getSinglePathKeyExtractor(keyPath);\n    }\n    else {\n        return obj => getByKeyPath(obj, keyPath);\n    }\n}\nfunction getSinglePathKeyExtractor(keyPath) {\n    const split = keyPath.split('.');\n    if (split.length === 1) {\n        return obj => obj[keyPath];\n    }\n    else {\n        return obj => getByKeyPath(obj, keyPath);\n    }\n}\n\nfunction arrayify(arrayLike) {\n    return [].slice.call(arrayLike);\n}\nlet _id_counter = 0;\nfunction getKeyPathAlias(keyPath) {\n    return keyPath == null ?\n        \":id\" :\n        typeof keyPath === 'string' ?\n            keyPath :\n            `[${keyPath.join('+')}]`;\n}\nfunction createDBCore(db, IdbKeyRange, tmpTrans) {\n    function extractSchema(db, trans) {\n        const tables = arrayify(db.objectStoreNames);\n        return {\n            schema: {\n                name: db.name,\n                tables: tables.map(table => trans.objectStore(table)).map(store => {\n                    const { keyPath, autoIncrement } = store;\n                    const compound = isArray(keyPath);\n                    const outbound = keyPath == null;\n                    const indexByKeyPath = {};\n                    const result = {\n                        name: store.name,\n                        primaryKey: {\n                            name: null,\n                            isPrimaryKey: true,\n                            outbound,\n                            compound,\n                            keyPath,\n                            autoIncrement,\n                            unique: true,\n                            extractKey: getKeyExtractor(keyPath)\n                        },\n                        indexes: arrayify(store.indexNames).map(indexName => store.index(indexName))\n                            .map(index => {\n                            const { name, unique, multiEntry, keyPath } = index;\n                            const compound = isArray(keyPath);\n                            const result = {\n                                name,\n                                compound,\n                                keyPath,\n                                unique,\n                                multiEntry,\n                                extractKey: getKeyExtractor(keyPath)\n                            };\n                            indexByKeyPath[getKeyPathAlias(keyPath)] = result;\n                            return result;\n                        }),\n                        getIndexByKeyPath: (keyPath) => indexByKeyPath[getKeyPathAlias(keyPath)]\n                    };\n                    indexByKeyPath[\":id\"] = result.primaryKey;\n                    if (keyPath != null) {\n                        indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;\n                    }\n                    return result;\n                })\n            },\n            hasGetAll: tables.length > 0 && ('getAll' in trans.objectStore(tables[0])) &&\n                !(typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n                    !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n                    [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604)\n        };\n    }\n    function makeIDBKeyRange(range) {\n        if (range.type === 3 )\n            return null;\n        if (range.type === 4 )\n            throw new Error(\"Cannot convert never type to IDBKeyRange\");\n        const { lower, upper, lowerOpen, upperOpen } = range;\n        const idbRange = lower === undefined ?\n            upper === undefined ?\n                null :\n                IdbKeyRange.upperBound(upper, !!upperOpen) :\n            upper === undefined ?\n                IdbKeyRange.lowerBound(lower, !!lowerOpen) :\n                IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);\n        return idbRange;\n    }\n    function createDbCoreTable(tableSchema) {\n        const tableName = tableSchema.name;\n        function mutate({ trans, type, keys, values, range }) {\n            return new Promise((resolve, reject) => {\n                resolve = wrap(resolve);\n                const store = trans.objectStore(tableName);\n                const outbound = store.keyPath == null;\n                const isAddOrPut = type === \"put\" || type === \"add\";\n                if (!isAddOrPut && type !== 'delete' && type !== 'deleteRange')\n                    throw new Error(\"Invalid operation type: \" + type);\n                const { length } = keys || values || { length: 1 };\n                if (keys && values && keys.length !== values.length) {\n                    throw new Error(\"Given keys array must have same length as given values array.\");\n                }\n                if (length === 0)\n                    return resolve({ numFailures: 0, failures: {}, results: [], lastResult: undefined });\n                let req;\n                const reqs = [];\n                const failures = [];\n                let numFailures = 0;\n                const errorHandler = event => {\n                    ++numFailures;\n                    preventDefault(event);\n                };\n                if (type === 'deleteRange') {\n                    if (range.type === 4 )\n                        return resolve({ numFailures, failures, results: [], lastResult: undefined });\n                    if (range.type === 3 )\n                        reqs.push(req = store.clear());\n                    else\n                        reqs.push(req = store.delete(makeIDBKeyRange(range)));\n                }\n                else {\n                    const [args1, args2] = isAddOrPut ?\n                        outbound ?\n                            [values, keys] :\n                            [values, null] :\n                        [keys, null];\n                    if (isAddOrPut) {\n                        for (let i = 0; i < length; ++i) {\n                            reqs.push(req = (args2 && args2[i] !== undefined ?\n                                store[type](args1[i], args2[i]) :\n                                store[type](args1[i])));\n                            req.onerror = errorHandler;\n                        }\n                    }\n                    else {\n                        for (let i = 0; i < length; ++i) {\n                            reqs.push(req = store[type](args1[i]));\n                            req.onerror = errorHandler;\n                        }\n                    }\n                }\n                const done = event => {\n                    const lastResult = event.target.result;\n                    reqs.forEach((req, i) => req.error != null && (failures[i] = req.error));\n                    resolve({\n                        numFailures,\n                        failures,\n                        results: type === \"delete\" ? keys : reqs.map(req => req.result),\n                        lastResult\n                    });\n                };\n                req.onerror = event => {\n                    errorHandler(event);\n                    done(event);\n                };\n                req.onsuccess = done;\n            });\n        }\n        function openCursor({ trans, values, query, reverse, unique }) {\n            return new Promise((resolve, reject) => {\n                resolve = wrap(resolve);\n                const { index, range } = query;\n                const store = trans.objectStore(tableName);\n                const source = index.isPrimaryKey ?\n                    store :\n                    store.index(index.name);\n                const direction = reverse ?\n                    unique ?\n                        \"prevunique\" :\n                        \"prev\" :\n                    unique ?\n                        \"nextunique\" :\n                        \"next\";\n                const req = values || !('openKeyCursor' in source) ?\n                    source.openCursor(makeIDBKeyRange(range), direction) :\n                    source.openKeyCursor(makeIDBKeyRange(range), direction);\n                req.onerror = eventRejectHandler(reject);\n                req.onsuccess = wrap(ev => {\n                    const cursor = req.result;\n                    if (!cursor) {\n                        resolve(null);\n                        return;\n                    }\n                    cursor.___id = ++_id_counter;\n                    cursor.done = false;\n                    const _cursorContinue = cursor.continue.bind(cursor);\n                    let _cursorContinuePrimaryKey = cursor.continuePrimaryKey;\n                    if (_cursorContinuePrimaryKey)\n                        _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);\n                    const _cursorAdvance = cursor.advance.bind(cursor);\n                    const doThrowCursorIsNotStarted = () => { throw new Error(\"Cursor not started\"); };\n                    const doThrowCursorIsStopped = () => { throw new Error(\"Cursor not stopped\"); };\n                    cursor.trans = trans;\n                    cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;\n                    cursor.fail = wrap(reject);\n                    cursor.next = function () {\n                        let gotOne = 1;\n                        return this.start(() => gotOne-- ? this.continue() : this.stop()).then(() => this);\n                    };\n                    cursor.start = (callback) => {\n                        const iterationPromise = new Promise((resolveIteration, rejectIteration) => {\n                            resolveIteration = wrap(resolveIteration);\n                            req.onerror = eventRejectHandler(rejectIteration);\n                            cursor.fail = rejectIteration;\n                            cursor.stop = value => {\n                                cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;\n                                resolveIteration(value);\n                            };\n                        });\n                        const guardedCallback = () => {\n                            if (req.result) {\n                                try {\n                                    callback();\n                                }\n                                catch (err) {\n                                    cursor.fail(err);\n                                }\n                            }\n                            else {\n                                cursor.done = true;\n                                cursor.start = () => { throw new Error(\"Cursor behind last entry\"); };\n                                cursor.stop();\n                            }\n                        };\n                        req.onsuccess = wrap(ev => {\n                            req.onsuccess = guardedCallback;\n                            guardedCallback();\n                        });\n                        cursor.continue = _cursorContinue;\n                        cursor.continuePrimaryKey = _cursorContinuePrimaryKey;\n                        cursor.advance = _cursorAdvance;\n                        guardedCallback();\n                        return iterationPromise;\n                    };\n                    resolve(cursor);\n                }, reject);\n            });\n        }\n        function query(hasGetAll) {\n            return (request) => {\n                return new Promise((resolve, reject) => {\n                    resolve = wrap(resolve);\n                    const { trans, values, limit, query } = request;\n                    const nonInfinitLimit = limit === Infinity ? undefined : limit;\n                    const { index, range } = query;\n                    const store = trans.objectStore(tableName);\n                    const source = index.isPrimaryKey ? store : store.index(index.name);\n                    const idbKeyRange = makeIDBKeyRange(range);\n                    if (limit === 0)\n                        return resolve({ result: [] });\n                    if (hasGetAll) {\n                        const req = values ?\n                            source.getAll(idbKeyRange, nonInfinitLimit) :\n                            source.getAllKeys(idbKeyRange, nonInfinitLimit);\n                        req.onsuccess = event => resolve({ result: event.target.result });\n                        req.onerror = eventRejectHandler(reject);\n                    }\n                    else {\n                        let count = 0;\n                        const req = values || !('openKeyCursor' in source) ?\n                            source.openCursor(idbKeyRange) :\n                            source.openKeyCursor(idbKeyRange);\n                        const result = [];\n                        req.onsuccess = event => {\n                            const cursor = req.result;\n                            if (!cursor)\n                                return resolve({ result });\n                            result.push(values ? cursor.value : cursor.primaryKey);\n                            if (++count === limit)\n                                return resolve({ result });\n                            cursor.continue();\n                        };\n                        req.onerror = eventRejectHandler(reject);\n                    }\n                });\n            };\n        }\n        return {\n            name: tableName,\n            schema: tableSchema,\n            mutate,\n            getMany({ trans, keys }) {\n                return new Promise((resolve, reject) => {\n                    resolve = wrap(resolve);\n                    const store = trans.objectStore(tableName);\n                    const length = keys.length;\n                    const result = new Array(length);\n                    let keyCount = 0;\n                    let callbackCount = 0;\n                    let req;\n                    const successHandler = event => {\n                        const req = event.target;\n                        if ((result[req._pos] = req.result) != null)\n                            ;\n                        if (++callbackCount === keyCount)\n                            resolve(result);\n                    };\n                    const errorHandler = eventRejectHandler(reject);\n                    for (let i = 0; i < length; ++i) {\n                        const key = keys[i];\n                        if (key != null) {\n                            req = store.get(keys[i]);\n                            req._pos = i;\n                            req.onsuccess = successHandler;\n                            req.onerror = errorHandler;\n                            ++keyCount;\n                        }\n                    }\n                    if (keyCount === 0)\n                        resolve(result);\n                });\n            },\n            get({ trans, key }) {\n                return new Promise((resolve, reject) => {\n                    resolve = wrap(resolve);\n                    const store = trans.objectStore(tableName);\n                    const req = store.get(key);\n                    req.onsuccess = event => resolve(event.target.result);\n                    req.onerror = eventRejectHandler(reject);\n                });\n            },\n            query: query(hasGetAll),\n            openCursor,\n            count({ query, trans }) {\n                const { index, range } = query;\n                return new Promise((resolve, reject) => {\n                    const store = trans.objectStore(tableName);\n                    const source = index.isPrimaryKey ? store : store.index(index.name);\n                    const idbKeyRange = makeIDBKeyRange(range);\n                    const req = idbKeyRange ? source.count(idbKeyRange) : source.count();\n                    req.onsuccess = wrap(ev => resolve(ev.target.result));\n                    req.onerror = eventRejectHandler(reject);\n                });\n            }\n        };\n    }\n    const { schema, hasGetAll } = extractSchema(db, tmpTrans);\n    const tables = schema.tables.map(tableSchema => createDbCoreTable(tableSchema));\n    const tableMap = {};\n    tables.forEach(table => tableMap[table.name] = table);\n    return {\n        stack: \"dbcore\",\n        transaction: db.transaction.bind(db),\n        table(name) {\n            const result = tableMap[name];\n            if (!result)\n                throw new Error(`Table '${name}' not found`);\n            return tableMap[name];\n        },\n        MIN_KEY: -Infinity,\n        MAX_KEY: getMaxKey(IdbKeyRange),\n        schema\n    };\n}\n\nfunction createMiddlewareStack(stackImpl, middlewares) {\n    return middlewares.reduce((down, { create }) => ({ ...down, ...create(down) }), stackImpl);\n}\nfunction createMiddlewareStacks(middlewares, idbdb, { IDBKeyRange, indexedDB }, tmpTrans) {\n    const dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);\n    return {\n        dbcore\n    };\n}\nfunction generateMiddlewareStacks({ _novip: db }, tmpTrans) {\n    const idbdb = tmpTrans.db;\n    const stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);\n    db.core = stacks.dbcore;\n    db.tables.forEach(table => {\n        const tableName = table.name;\n        if (db.core.schema.tables.some(tbl => tbl.name === tableName)) {\n            table.core = db.core.table(tableName);\n            if (db[tableName] instanceof db.Table) {\n                db[tableName].core = table.core;\n            }\n        }\n    });\n}\n\nfunction setApiOnPlace({ _novip: db }, objs, tableNames, dbschema) {\n    tableNames.forEach(tableName => {\n        const schema = dbschema[tableName];\n        objs.forEach(obj => {\n            const propDesc = getPropertyDescriptor(obj, tableName);\n            if (!propDesc || (\"value\" in propDesc && propDesc.value === undefined)) {\n                if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {\n                    setProp(obj, tableName, {\n                        get() { return this.table(tableName); },\n                        set(value) {\n                            defineProperty(this, tableName, { value, writable: true, configurable: true, enumerable: true });\n                        }\n                    });\n                }\n                else {\n                    obj[tableName] = new db.Table(tableName, schema);\n                }\n            }\n        });\n    });\n}\nfunction removeTablesApi({ _novip: db }, objs) {\n    objs.forEach(obj => {\n        for (let key in obj) {\n            if (obj[key] instanceof db.Table)\n                delete obj[key];\n        }\n    });\n}\nfunction lowerVersionFirst(a, b) {\n    return a._cfg.version - b._cfg.version;\n}\nfunction runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {\n    const globalSchema = db._dbSchema;\n    const trans = db._createTransaction('readwrite', db._storeNames, globalSchema);\n    trans.create(idbUpgradeTrans);\n    trans._completion.catch(reject);\n    const rejectTransaction = trans._reject.bind(trans);\n    const transless = PSD.transless || PSD;\n    newScope(() => {\n        PSD.trans = trans;\n        PSD.transless = transless;\n        if (oldVersion === 0) {\n            keys(globalSchema).forEach(tableName => {\n                createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);\n            });\n            generateMiddlewareStacks(db, idbUpgradeTrans);\n            DexiePromise.follow(() => db.on.populate.fire(trans)).catch(rejectTransaction);\n        }\n        else\n            updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans).catch(rejectTransaction);\n    });\n}\nfunction updateTablesAndIndexes({ _novip: db }, oldVersion, trans, idbUpgradeTrans) {\n    const queue = [];\n    const versions = db._versions;\n    let globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n    let anyContentUpgraderHasRun = false;\n    const versToRun = versions.filter(v => v._cfg.version >= oldVersion);\n    versToRun.forEach(version => {\n        queue.push(() => {\n            const oldSchema = globalSchema;\n            const newSchema = version._cfg.dbschema;\n            adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);\n            adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);\n            globalSchema = db._dbSchema = newSchema;\n            const diff = getSchemaDiff(oldSchema, newSchema);\n            diff.add.forEach(tuple => {\n                createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);\n            });\n            diff.change.forEach(change => {\n                if (change.recreate) {\n                    throw new exceptions.Upgrade(\"Not yet support for changing primary key\");\n                }\n                else {\n                    const store = idbUpgradeTrans.objectStore(change.name);\n                    change.add.forEach(idx => addIndex(store, idx));\n                    change.change.forEach(idx => {\n                        store.deleteIndex(idx.name);\n                        addIndex(store, idx);\n                    });\n                    change.del.forEach(idxName => store.deleteIndex(idxName));\n                }\n            });\n            const contentUpgrade = version._cfg.contentUpgrade;\n            if (contentUpgrade && version._cfg.version > oldVersion) {\n                generateMiddlewareStacks(db, idbUpgradeTrans);\n                trans._memoizedTables = {};\n                anyContentUpgraderHasRun = true;\n                let upgradeSchema = shallowClone(newSchema);\n                diff.del.forEach(table => {\n                    upgradeSchema[table] = oldSchema[table];\n                });\n                removeTablesApi(db, [db.Transaction.prototype]);\n                setApiOnPlace(db, [db.Transaction.prototype], keys(upgradeSchema), upgradeSchema);\n                trans.schema = upgradeSchema;\n                const contentUpgradeIsAsync = isAsyncFunction(contentUpgrade);\n                if (contentUpgradeIsAsync) {\n                    incrementExpectedAwaits();\n                }\n                let returnValue;\n                const promiseFollowed = DexiePromise.follow(() => {\n                    returnValue = contentUpgrade(trans);\n                    if (returnValue) {\n                        if (contentUpgradeIsAsync) {\n                            var decrementor = decrementExpectedAwaits.bind(null, null);\n                            returnValue.then(decrementor, decrementor);\n                        }\n                    }\n                });\n                return (returnValue && typeof returnValue.then === 'function' ?\n                    DexiePromise.resolve(returnValue) : promiseFollowed.then(() => returnValue));\n            }\n        });\n        queue.push(idbtrans => {\n            if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {\n                const newSchema = version._cfg.dbschema;\n                deleteRemovedTables(newSchema, idbtrans);\n            }\n            removeTablesApi(db, [db.Transaction.prototype]);\n            setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);\n            trans.schema = db._dbSchema;\n        });\n    });\n    function runQueue() {\n        return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) :\n            DexiePromise.resolve();\n    }\n    return runQueue().then(() => {\n        createMissingTables(globalSchema, idbUpgradeTrans);\n    });\n}\nfunction getSchemaDiff(oldSchema, newSchema) {\n    const diff = {\n        del: [],\n        add: [],\n        change: []\n    };\n    let table;\n    for (table in oldSchema) {\n        if (!newSchema[table])\n            diff.del.push(table);\n    }\n    for (table in newSchema) {\n        const oldDef = oldSchema[table], newDef = newSchema[table];\n        if (!oldDef) {\n            diff.add.push([table, newDef]);\n        }\n        else {\n            const change = {\n                name: table,\n                def: newDef,\n                recreate: false,\n                del: [],\n                add: [],\n                change: []\n            };\n            if ((\n            '' + (oldDef.primKey.keyPath || '')) !== ('' + (newDef.primKey.keyPath || '')) ||\n                (oldDef.primKey.auto !== newDef.primKey.auto && !isIEOrEdge))\n             {\n                change.recreate = true;\n                diff.change.push(change);\n            }\n            else {\n                const oldIndexes = oldDef.idxByName;\n                const newIndexes = newDef.idxByName;\n                let idxName;\n                for (idxName in oldIndexes) {\n                    if (!newIndexes[idxName])\n                        change.del.push(idxName);\n                }\n                for (idxName in newIndexes) {\n                    const oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];\n                    if (!oldIdx)\n                        change.add.push(newIdx);\n                    else if (oldIdx.src !== newIdx.src)\n                        change.change.push(newIdx);\n                }\n                if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {\n                    diff.change.push(change);\n                }\n            }\n        }\n    }\n    return diff;\n}\nfunction createTable(idbtrans, tableName, primKey, indexes) {\n    const store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ?\n        { keyPath: primKey.keyPath, autoIncrement: primKey.auto } :\n        { autoIncrement: primKey.auto });\n    indexes.forEach(idx => addIndex(store, idx));\n    return store;\n}\nfunction createMissingTables(newSchema, idbtrans) {\n    keys(newSchema).forEach(tableName => {\n        if (!idbtrans.db.objectStoreNames.contains(tableName)) {\n            createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);\n        }\n    });\n}\nfunction deleteRemovedTables(newSchema, idbtrans) {\n    [].slice.call(idbtrans.db.objectStoreNames).forEach(storeName => newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName));\n}\nfunction addIndex(store, idx) {\n    store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });\n}\nfunction buildGlobalSchema(db, idbdb, tmpTrans) {\n    const globalSchema = {};\n    const dbStoreNames = slice(idbdb.objectStoreNames, 0);\n    dbStoreNames.forEach(storeName => {\n        const store = tmpTrans.objectStore(storeName);\n        let keyPath = store.keyPath;\n        const primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || \"\", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== \"string\", true);\n        const indexes = [];\n        for (let j = 0; j < store.indexNames.length; ++j) {\n            const idbindex = store.index(store.indexNames[j]);\n            keyPath = idbindex.keyPath;\n            var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== \"string\", false);\n            indexes.push(index);\n        }\n        globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);\n    });\n    return globalSchema;\n}\nfunction readGlobalSchema({ _novip: db }, idbdb, tmpTrans) {\n    db.verno = idbdb.version / 10;\n    const globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);\n    db._storeNames = slice(idbdb.objectStoreNames, 0);\n    setApiOnPlace(db, [db._allTables], keys(globalSchema), globalSchema);\n}\nfunction verifyInstalledSchema(db, tmpTrans) {\n    const installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);\n    const diff = getSchemaDiff(installedSchema, db._dbSchema);\n    return !(diff.add.length || diff.change.some(ch => ch.add.length || ch.change.length));\n}\nfunction adjustToExistingIndexNames({ _novip: db }, schema, idbtrans) {\n    const storeNames = idbtrans.db.objectStoreNames;\n    for (let i = 0; i < storeNames.length; ++i) {\n        const storeName = storeNames[i];\n        const store = idbtrans.objectStore(storeName);\n        db._hasGetAll = 'getAll' in store;\n        for (let j = 0; j < store.indexNames.length; ++j) {\n            const indexName = store.indexNames[j];\n            const keyPath = store.index(indexName).keyPath;\n            const dexieName = typeof keyPath === 'string' ? keyPath : \"[\" + slice(keyPath).join('+') + \"]\";\n            if (schema[storeName]) {\n                const indexSpec = schema[storeName].idxByName[dexieName];\n                if (indexSpec) {\n                    indexSpec.name = indexName;\n                    delete schema[storeName].idxByName[dexieName];\n                    schema[storeName].idxByName[indexName] = indexSpec;\n                }\n            }\n        }\n    }\n    if (typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n        !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n        _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope &&\n        [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604) {\n        db._hasGetAll = false;\n    }\n}\nfunction parseIndexSyntax(primKeyAndIndexes) {\n    return primKeyAndIndexes.split(',').map((index, indexNum) => {\n        index = index.trim();\n        const name = index.replace(/([&*]|\\+\\+)/g, \"\");\n        const keyPath = /^\\[/.test(name) ? name.match(/^\\[(.*)\\]$/)[1].split('+') : name;\n        return createIndexSpec(name, keyPath || null, /\\&/.test(index), /\\*/.test(index), /\\+\\+/.test(index), isArray(keyPath), indexNum === 0);\n    });\n}\n\nclass Version {\n    _parseStoresSpec(stores, outSchema) {\n        keys(stores).forEach(tableName => {\n            if (stores[tableName] !== null) {\n                var indexes = parseIndexSyntax(stores[tableName]);\n                var primKey = indexes.shift();\n                if (primKey.multi)\n                    throw new exceptions.Schema(\"Primary key cannot be multi-valued\");\n                indexes.forEach(idx => {\n                    if (idx.auto)\n                        throw new exceptions.Schema(\"Only primary key can be marked as autoIncrement (++)\");\n                    if (!idx.keyPath)\n                        throw new exceptions.Schema(\"Index must have a name and cannot be an empty string\");\n                });\n                outSchema[tableName] = createTableSchema(tableName, primKey, indexes);\n            }\n        });\n    }\n    stores(stores) {\n        const db = this.db;\n        this._cfg.storesSource = this._cfg.storesSource ?\n            extend(this._cfg.storesSource, stores) :\n            stores;\n        const versions = db._versions;\n        const storesSpec = {};\n        let dbschema = {};\n        versions.forEach(version => {\n            extend(storesSpec, version._cfg.storesSource);\n            dbschema = (version._cfg.dbschema = {});\n            version._parseStoresSpec(storesSpec, dbschema);\n        });\n        db._dbSchema = dbschema;\n        removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);\n        setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);\n        db._storeNames = keys(dbschema);\n        return this;\n    }\n    upgrade(upgradeFunction) {\n        this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);\n        return this;\n    }\n}\n\nfunction createVersionConstructor(db) {\n    return makeClassConstructor(Version.prototype, function Version(versionNumber) {\n        this.db = db;\n        this._cfg = {\n            version: versionNumber,\n            storesSource: null,\n            dbschema: {},\n            tables: {},\n            contentUpgrade: null\n        };\n    });\n}\n\nfunction getDbNamesTable(indexedDB, IDBKeyRange) {\n    let dbNamesDB = indexedDB[\"_dbNamesDB\"];\n    if (!dbNamesDB) {\n        dbNamesDB = indexedDB[\"_dbNamesDB\"] = new Dexie$1(DBNAMES_DB, {\n            addons: [],\n            indexedDB,\n            IDBKeyRange,\n        });\n        dbNamesDB.version(1).stores({ dbnames: \"name\" });\n    }\n    return dbNamesDB.table(\"dbnames\");\n}\nfunction hasDatabasesNative(indexedDB) {\n    return indexedDB && typeof indexedDB.databases === \"function\";\n}\nfunction getDatabaseNames({ indexedDB, IDBKeyRange, }) {\n    return hasDatabasesNative(indexedDB)\n        ? Promise.resolve(indexedDB.databases()).then((infos) => infos\n            .map((info) => info.name)\n            .filter((name) => name !== DBNAMES_DB))\n        : getDbNamesTable(indexedDB, IDBKeyRange).toCollection().primaryKeys();\n}\nfunction _onDatabaseCreated({ indexedDB, IDBKeyRange }, name) {\n    !hasDatabasesNative(indexedDB) &&\n        name !== DBNAMES_DB &&\n        getDbNamesTable(indexedDB, IDBKeyRange).put({ name }).catch(nop);\n}\nfunction _onDatabaseDeleted({ indexedDB, IDBKeyRange }, name) {\n    !hasDatabasesNative(indexedDB) &&\n        name !== DBNAMES_DB &&\n        getDbNamesTable(indexedDB, IDBKeyRange).delete(name).catch(nop);\n}\n\nfunction vip(fn) {\n    return newScope(function () {\n        PSD.letThrough = true;\n        return fn();\n    });\n}\n\nfunction idbReady() {\n    var isSafari = !navigator.userAgentData &&\n        /Safari\\//.test(navigator.userAgent) &&\n        !/Chrom(e|ium)\\//.test(navigator.userAgent);\n    if (!isSafari || !indexedDB.databases)\n        return Promise.resolve();\n    var intervalId;\n    return new Promise(function (resolve) {\n        var tryIdb = function () { return indexedDB.databases().finally(resolve); };\n        intervalId = setInterval(tryIdb, 100);\n        tryIdb();\n    }).finally(function () { return clearInterval(intervalId); });\n}\n\nfunction dexieOpen(db) {\n    const state = db._state;\n    const { indexedDB } = db._deps;\n    if (state.isBeingOpened || db.idbdb)\n        return state.dbReadyPromise.then(() => state.dbOpenError ?\n            rejection(state.dbOpenError) :\n            db);\n    debug && (state.openCanceller._stackHolder = getErrorWithStack());\n    state.isBeingOpened = true;\n    state.dbOpenError = null;\n    state.openComplete = false;\n    const openCanceller = state.openCanceller;\n    function throwIfCancelled() {\n        if (state.openCanceller !== openCanceller)\n            throw new exceptions.DatabaseClosed('db.open() was cancelled');\n    }\n    let resolveDbReady = state.dbReadyResolve,\n    upgradeTransaction = null, wasCreated = false;\n    return DexiePromise.race([openCanceller, (typeof navigator === 'undefined' ? DexiePromise.resolve() : idbReady()).then(() => new DexiePromise((resolve, reject) => {\n            throwIfCancelled();\n            if (!indexedDB)\n                throw new exceptions.MissingAPI();\n            const dbName = db.name;\n            const req = state.autoSchema ?\n                indexedDB.open(dbName) :\n                indexedDB.open(dbName, Math.round(db.verno * 10));\n            if (!req)\n                throw new exceptions.MissingAPI();\n            req.onerror = eventRejectHandler(reject);\n            req.onblocked = wrap(db._fireOnBlocked);\n            req.onupgradeneeded = wrap(e => {\n                upgradeTransaction = req.transaction;\n                if (state.autoSchema && !db._options.allowEmptyDB) {\n                    req.onerror = preventDefault;\n                    upgradeTransaction.abort();\n                    req.result.close();\n                    const delreq = indexedDB.deleteDatabase(dbName);\n                    delreq.onsuccess = delreq.onerror = wrap(() => {\n                        reject(new exceptions.NoSuchDatabase(`Database ${dbName} doesnt exist`));\n                    });\n                }\n                else {\n                    upgradeTransaction.onerror = eventRejectHandler(reject);\n                    var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;\n                    wasCreated = oldVer < 1;\n                    db._novip.idbdb = req.result;\n                    runUpgraders(db, oldVer / 10, upgradeTransaction, reject);\n                }\n            }, reject);\n            req.onsuccess = wrap(() => {\n                upgradeTransaction = null;\n                const idbdb = db._novip.idbdb = req.result;\n                const objectStoreNames = slice(idbdb.objectStoreNames);\n                if (objectStoreNames.length > 0)\n                    try {\n                        const tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), 'readonly');\n                        if (state.autoSchema)\n                            readGlobalSchema(db, idbdb, tmpTrans);\n                        else {\n                            adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);\n                            if (!verifyInstalledSchema(db, tmpTrans)) {\n                                console.warn(`Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.`);\n                            }\n                        }\n                        generateMiddlewareStacks(db, tmpTrans);\n                    }\n                    catch (e) {\n                    }\n                connections.push(db);\n                idbdb.onversionchange = wrap(ev => {\n                    state.vcFired = true;\n                    db.on(\"versionchange\").fire(ev);\n                });\n                idbdb.onclose = wrap(ev => {\n                    db.on(\"close\").fire(ev);\n                });\n                if (wasCreated)\n                    _onDatabaseCreated(db._deps, dbName);\n                resolve();\n            }, reject);\n        }))]).then(() => {\n        throwIfCancelled();\n        state.onReadyBeingFired = [];\n        return DexiePromise.resolve(vip(() => db.on.ready.fire(db.vip))).then(function fireRemainders() {\n            if (state.onReadyBeingFired.length > 0) {\n                let remainders = state.onReadyBeingFired.reduce(promisableChain, nop);\n                state.onReadyBeingFired = [];\n                return DexiePromise.resolve(vip(() => remainders(db.vip))).then(fireRemainders);\n            }\n        });\n    }).finally(() => {\n        state.onReadyBeingFired = null;\n        state.isBeingOpened = false;\n    }).then(() => {\n        return db;\n    }).catch(err => {\n        state.dbOpenError = err;\n        try {\n            upgradeTransaction && upgradeTransaction.abort();\n        }\n        catch (_a) { }\n        if (openCanceller === state.openCanceller) {\n            db._close();\n        }\n        return rejection(err);\n    }).finally(() => {\n        state.openComplete = true;\n        resolveDbReady();\n    });\n}\n\nfunction awaitIterator(iterator) {\n    var callNext = result => iterator.next(result), doThrow = error => iterator.throw(error), onSuccess = step(callNext), onError = step(doThrow);\n    function step(getNext) {\n        return (val) => {\n            var next = getNext(val), value = next.value;\n            return next.done ? value :\n                (!value || typeof value.then !== 'function' ?\n                    isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) :\n                    value.then(onSuccess, onError));\n        };\n    }\n    return step(callNext)();\n}\n\nfunction extractTransactionArgs(mode, _tableArgs_, scopeFunc) {\n    var i = arguments.length;\n    if (i < 2)\n        throw new exceptions.InvalidArgument(\"Too few arguments\");\n    var args = new Array(i - 1);\n    while (--i)\n        args[i - 1] = arguments[i];\n    scopeFunc = args.pop();\n    var tables = flatten(args);\n    return [mode, tables, scopeFunc];\n}\nfunction enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {\n    return DexiePromise.resolve().then(() => {\n        const transless = PSD.transless || PSD;\n        const trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);\n        const zoneProps = {\n            trans: trans,\n            transless: transless\n        };\n        if (parentTransaction) {\n            trans.idbtrans = parentTransaction.idbtrans;\n        }\n        else {\n            trans.create();\n        }\n        const scopeFuncIsAsync = isAsyncFunction(scopeFunc);\n        if (scopeFuncIsAsync) {\n            incrementExpectedAwaits();\n        }\n        let returnValue;\n        const promiseFollowed = DexiePromise.follow(() => {\n            returnValue = scopeFunc.call(trans, trans);\n            if (returnValue) {\n                if (scopeFuncIsAsync) {\n                    var decrementor = decrementExpectedAwaits.bind(null, null);\n                    returnValue.then(decrementor, decrementor);\n                }\n                else if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {\n                    returnValue = awaitIterator(returnValue);\n                }\n            }\n        }, zoneProps);\n        return (returnValue && typeof returnValue.then === 'function' ?\n            DexiePromise.resolve(returnValue).then(x => trans.active ?\n                x\n                : rejection(new exceptions.PrematureCommit(\"Transaction committed too early. See http://bit.ly/2kdckMn\")))\n            : promiseFollowed.then(() => returnValue)).then(x => {\n            if (parentTransaction)\n                trans._resolve();\n            return trans._completion.then(() => x);\n        }).catch(e => {\n            trans._reject(e);\n            return rejection(e);\n        });\n    });\n}\n\nfunction pad(a, value, count) {\n    const result = isArray(a) ? a.slice() : [a];\n    for (let i = 0; i < count; ++i)\n        result.push(value);\n    return result;\n}\nfunction createVirtualIndexMiddleware(down) {\n    return {\n        ...down,\n        table(tableName) {\n            const table = down.table(tableName);\n            const { schema } = table;\n            const indexLookup = {};\n            const allVirtualIndexes = [];\n            function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {\n                const keyPathAlias = getKeyPathAlias(keyPath);\n                const indexList = (indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || []);\n                const keyLength = keyPath == null ? 0 : typeof keyPath === 'string' ? 1 : keyPath.length;\n                const isVirtual = keyTail > 0;\n                const virtualIndex = {\n                    ...lowLevelIndex,\n                    isVirtual,\n                    keyTail,\n                    keyLength,\n                    extractKey: getKeyExtractor(keyPath),\n                    unique: !isVirtual && lowLevelIndex.unique\n                };\n                indexList.push(virtualIndex);\n                if (!virtualIndex.isPrimaryKey) {\n                    allVirtualIndexes.push(virtualIndex);\n                }\n                if (keyLength > 1) {\n                    const virtualKeyPath = keyLength === 2 ?\n                        keyPath[0] :\n                        keyPath.slice(0, keyLength - 1);\n                    addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);\n                }\n                indexList.sort((a, b) => a.keyTail - b.keyTail);\n                return virtualIndex;\n            }\n            const primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);\n            indexLookup[\":id\"] = [primaryKey];\n            for (const index of schema.indexes) {\n                addVirtualIndexes(index.keyPath, 0, index);\n            }\n            function findBestIndex(keyPath) {\n                const result = indexLookup[getKeyPathAlias(keyPath)];\n                return result && result[0];\n            }\n            function translateRange(range, keyTail) {\n                return {\n                    type: range.type === 1  ?\n                        2  :\n                        range.type,\n                    lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),\n                    lowerOpen: true,\n                    upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),\n                    upperOpen: true\n                };\n            }\n            function translateRequest(req) {\n                const index = req.query.index;\n                return index.isVirtual ? {\n                    ...req,\n                    query: {\n                        index,\n                        range: translateRange(req.query.range, index.keyTail)\n                    }\n                } : req;\n            }\n            const result = {\n                ...table,\n                schema: {\n                    ...schema,\n                    primaryKey,\n                    indexes: allVirtualIndexes,\n                    getIndexByKeyPath: findBestIndex\n                },\n                count(req) {\n                    return table.count(translateRequest(req));\n                },\n                query(req) {\n                    return table.query(translateRequest(req));\n                },\n                openCursor(req) {\n                    const { keyTail, isVirtual, keyLength } = req.query.index;\n                    if (!isVirtual)\n                        return table.openCursor(req);\n                    function createVirtualCursor(cursor) {\n                        function _continue(key) {\n                            key != null ?\n                                cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) :\n                                req.unique ?\n                                    cursor.continue(cursor.key.slice(0, keyLength)\n                                        .concat(req.reverse\n                                        ? down.MIN_KEY\n                                        : down.MAX_KEY, keyTail)) :\n                                    cursor.continue();\n                        }\n                        const virtualCursor = Object.create(cursor, {\n                            continue: { value: _continue },\n                            continuePrimaryKey: {\n                                value(key, primaryKey) {\n                                    cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);\n                                }\n                            },\n                            primaryKey: {\n                                get() {\n                                    return cursor.primaryKey;\n                                }\n                            },\n                            key: {\n                                get() {\n                                    const key = cursor.key;\n                                    return keyLength === 1 ?\n                                        key[0] :\n                                        key.slice(0, keyLength);\n                                }\n                            },\n                            value: {\n                                get() {\n                                    return cursor.value;\n                                }\n                            }\n                        });\n                        return virtualCursor;\n                    }\n                    return table.openCursor(translateRequest(req))\n                        .then(cursor => cursor && createVirtualCursor(cursor));\n                }\n            };\n            return result;\n        }\n    };\n}\nconst virtualIndexMiddleware = {\n    stack: \"dbcore\",\n    name: \"VirtualIndexMiddleware\",\n    level: 1,\n    create: createVirtualIndexMiddleware\n};\n\nfunction getObjectDiff(a, b, rv, prfx) {\n    rv = rv || {};\n    prfx = prfx || '';\n    keys(a).forEach((prop) => {\n        if (!hasOwn(b, prop)) {\n            rv[prfx + prop] = undefined;\n        }\n        else {\n            var ap = a[prop], bp = b[prop];\n            if (typeof ap === 'object' && typeof bp === 'object' && ap && bp) {\n                const apTypeName = toStringTag(ap);\n                const bpTypeName = toStringTag(bp);\n                if (apTypeName !== bpTypeName) {\n                    rv[prfx + prop] = b[prop];\n                }\n                else if (apTypeName === 'Object') {\n                    getObjectDiff(ap, bp, rv, prfx + prop + '.');\n                }\n                else if (ap !== bp) {\n                    rv[prfx + prop] = b[prop];\n                }\n            }\n            else if (ap !== bp)\n                rv[prfx + prop] = b[prop];\n        }\n    });\n    keys(b).forEach((prop) => {\n        if (!hasOwn(a, prop)) {\n            rv[prfx + prop] = b[prop];\n        }\n    });\n    return rv;\n}\n\nfunction getEffectiveKeys(primaryKey, req) {\n    if (req.type === 'delete')\n        return req.keys;\n    return req.keys || req.values.map(primaryKey.extractKey);\n}\n\nconst hooksMiddleware = {\n    stack: \"dbcore\",\n    name: \"HooksMiddleware\",\n    level: 2,\n    create: (downCore) => ({\n        ...downCore,\n        table(tableName) {\n            const downTable = downCore.table(tableName);\n            const { primaryKey } = downTable.schema;\n            const tableMiddleware = {\n                ...downTable,\n                mutate(req) {\n                    const dxTrans = PSD.trans;\n                    const { deleting, creating, updating } = dxTrans.table(tableName).hook;\n                    switch (req.type) {\n                        case 'add':\n                            if (creating.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);\n                        case 'put':\n                            if (creating.fire === nop && updating.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);\n                        case 'delete':\n                            if (deleting.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);\n                        case 'deleteRange':\n                            if (deleting.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => deleteRange(req), true);\n                    }\n                    return downTable.mutate(req);\n                    function addPutOrDelete(req) {\n                        const dxTrans = PSD.trans;\n                        const keys = req.keys || getEffectiveKeys(primaryKey, req);\n                        if (!keys)\n                            throw new Error(\"Keys missing\");\n                        req = req.type === 'add' || req.type === 'put' ?\n                            { ...req, keys } :\n                            { ...req };\n                        if (req.type !== 'delete')\n                            req.values = [...req.values];\n                        if (req.keys)\n                            req.keys = [...req.keys];\n                        return getExistingValues(downTable, req, keys).then(existingValues => {\n                            const contexts = keys.map((key, i) => {\n                                const existingValue = existingValues[i];\n                                const ctx = { onerror: null, onsuccess: null };\n                                if (req.type === 'delete') {\n                                    deleting.fire.call(ctx, key, existingValue, dxTrans);\n                                }\n                                else if (req.type === 'add' || existingValue === undefined) {\n                                    const generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);\n                                    if (key == null && generatedPrimaryKey != null) {\n                                        key = generatedPrimaryKey;\n                                        req.keys[i] = key;\n                                        if (!primaryKey.outbound) {\n                                            setByKeyPath(req.values[i], primaryKey.keyPath, key);\n                                        }\n                                    }\n                                }\n                                else {\n                                    const objectDiff = getObjectDiff(existingValue, req.values[i]);\n                                    const additionalChanges = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);\n                                    if (additionalChanges) {\n                                        const requestedValue = req.values[i];\n                                        Object.keys(additionalChanges).forEach(keyPath => {\n                                            if (hasOwn(requestedValue, keyPath)) {\n                                                requestedValue[keyPath] = additionalChanges[keyPath];\n                                            }\n                                            else {\n                                                setByKeyPath(requestedValue, keyPath, additionalChanges[keyPath]);\n                                            }\n                                        });\n                                    }\n                                }\n                                return ctx;\n                            });\n                            return downTable.mutate(req).then(({ failures, results, numFailures, lastResult }) => {\n                                for (let i = 0; i < keys.length; ++i) {\n                                    const primKey = results ? results[i] : keys[i];\n                                    const ctx = contexts[i];\n                                    if (primKey == null) {\n                                        ctx.onerror && ctx.onerror(failures[i]);\n                                    }\n                                    else {\n                                        ctx.onsuccess && ctx.onsuccess(req.type === 'put' && existingValues[i] ?\n                                            req.values[i] :\n                                            primKey\n                                        );\n                                    }\n                                }\n                                return { failures, results, numFailures, lastResult };\n                            }).catch(error => {\n                                contexts.forEach(ctx => ctx.onerror && ctx.onerror(error));\n                                return Promise.reject(error);\n                            });\n                        });\n                    }\n                    function deleteRange(req) {\n                        return deleteNextChunk(req.trans, req.range, 10000);\n                    }\n                    function deleteNextChunk(trans, range, limit) {\n                        return downTable.query({ trans, values: false, query: { index: primaryKey, range }, limit })\n                            .then(({ result }) => {\n                            return addPutOrDelete({ type: 'delete', keys: result, trans }).then(res => {\n                                if (res.numFailures > 0)\n                                    return Promise.reject(res.failures[0]);\n                                if (result.length < limit) {\n                                    return { failures: [], numFailures: 0, lastResult: undefined };\n                                }\n                                else {\n                                    return deleteNextChunk(trans, { ...range, lower: result[result.length - 1], lowerOpen: true }, limit);\n                                }\n                            });\n                        });\n                    }\n                }\n            };\n            return tableMiddleware;\n        },\n    })\n};\nfunction getExistingValues(table, req, effectiveKeys) {\n    return req.type === \"add\"\n        ? Promise.resolve([])\n        : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: \"immutable\" });\n}\n\nfunction getFromTransactionCache(keys, cache, clone) {\n    try {\n        if (!cache)\n            return null;\n        if (cache.keys.length < keys.length)\n            return null;\n        const result = [];\n        for (let i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i) {\n            if (cmp(cache.keys[i], keys[j]) !== 0)\n                continue;\n            result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);\n            ++j;\n        }\n        return result.length === keys.length ? result : null;\n    }\n    catch (_a) {\n        return null;\n    }\n}\nconst cacheExistingValuesMiddleware = {\n    stack: \"dbcore\",\n    level: -1,\n    create: (core) => {\n        return {\n            table: (tableName) => {\n                const table = core.table(tableName);\n                return {\n                    ...table,\n                    getMany: (req) => {\n                        if (!req.cache) {\n                            return table.getMany(req);\n                        }\n                        const cachedResult = getFromTransactionCache(req.keys, req.trans[\"_cache\"], req.cache === \"clone\");\n                        if (cachedResult) {\n                            return DexiePromise.resolve(cachedResult);\n                        }\n                        return table.getMany(req).then((res) => {\n                            req.trans[\"_cache\"] = {\n                                keys: req.keys,\n                                values: req.cache === \"clone\" ? deepClone(res) : res,\n                            };\n                            return res;\n                        });\n                    },\n                    mutate: (req) => {\n                        if (req.type !== \"add\")\n                            req.trans[\"_cache\"] = null;\n                        return table.mutate(req);\n                    },\n                };\n            },\n        };\n    },\n};\n\nfunction isEmptyRange(node) {\n    return !(\"from\" in node);\n}\nconst RangeSet = function (fromOrTree, to) {\n    if (this) {\n        extend(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });\n    }\n    else {\n        const rv = new RangeSet();\n        if (fromOrTree && (\"d\" in fromOrTree)) {\n            extend(rv, fromOrTree);\n        }\n        return rv;\n    }\n};\nprops(RangeSet.prototype, {\n    add(rangeSet) {\n        mergeRanges(this, rangeSet);\n        return this;\n    },\n    addKey(key) {\n        addRange(this, key, key);\n        return this;\n    },\n    addKeys(keys) {\n        keys.forEach(key => addRange(this, key, key));\n        return this;\n    },\n    [iteratorSymbol]() {\n        return getRangeSetIterator(this);\n    }\n});\nfunction addRange(target, from, to) {\n    const diff = cmp(from, to);\n    if (isNaN(diff))\n        return;\n    if (diff > 0)\n        throw RangeError();\n    if (isEmptyRange(target))\n        return extend(target, { from, to, d: 1 });\n    const left = target.l;\n    const right = target.r;\n    if (cmp(to, target.from) < 0) {\n        left\n            ? addRange(left, from, to)\n            : (target.l = { from, to, d: 1, l: null, r: null });\n        return rebalance(target);\n    }\n    if (cmp(from, target.to) > 0) {\n        right\n            ? addRange(right, from, to)\n            : (target.r = { from, to, d: 1, l: null, r: null });\n        return rebalance(target);\n    }\n    if (cmp(from, target.from) < 0) {\n        target.from = from;\n        target.l = null;\n        target.d = right ? right.d + 1 : 1;\n    }\n    if (cmp(to, target.to) > 0) {\n        target.to = to;\n        target.r = null;\n        target.d = target.l ? target.l.d + 1 : 1;\n    }\n    const rightWasCutOff = !target.r;\n    if (left && !target.l) {\n        mergeRanges(target, left);\n    }\n    if (right && rightWasCutOff) {\n        mergeRanges(target, right);\n    }\n}\nfunction mergeRanges(target, newSet) {\n    function _addRangeSet(target, { from, to, l, r }) {\n        addRange(target, from, to);\n        if (l)\n            _addRangeSet(target, l);\n        if (r)\n            _addRangeSet(target, r);\n    }\n    if (!isEmptyRange(newSet))\n        _addRangeSet(target, newSet);\n}\nfunction rangesOverlap(rangeSet1, rangeSet2) {\n    const i1 = getRangeSetIterator(rangeSet2);\n    let nextResult1 = i1.next();\n    if (nextResult1.done)\n        return false;\n    let a = nextResult1.value;\n    const i2 = getRangeSetIterator(rangeSet1);\n    let nextResult2 = i2.next(a.from);\n    let b = nextResult2.value;\n    while (!nextResult1.done && !nextResult2.done) {\n        if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0)\n            return true;\n        cmp(a.from, b.from) < 0\n            ? (a = (nextResult1 = i1.next(b.from)).value)\n            : (b = (nextResult2 = i2.next(a.from)).value);\n    }\n    return false;\n}\nfunction getRangeSetIterator(node) {\n    let state = isEmptyRange(node) ? null : { s: 0, n: node };\n    return {\n        next(key) {\n            const keyProvided = arguments.length > 0;\n            while (state) {\n                switch (state.s) {\n                    case 0:\n                        state.s = 1;\n                        if (keyProvided) {\n                            while (state.n.l && cmp(key, state.n.from) < 0)\n                                state = { up: state, n: state.n.l, s: 1 };\n                        }\n                        else {\n                            while (state.n.l)\n                                state = { up: state, n: state.n.l, s: 1 };\n                        }\n                    case 1:\n                        state.s = 2;\n                        if (!keyProvided || cmp(key, state.n.to) <= 0)\n                            return { value: state.n, done: false };\n                    case 2:\n                        if (state.n.r) {\n                            state.s = 3;\n                            state = { up: state, n: state.n.r, s: 0 };\n                            continue;\n                        }\n                    case 3:\n                        state = state.up;\n                }\n            }\n            return { done: true };\n        },\n    };\n}\nfunction rebalance(target) {\n    var _a, _b;\n    const diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);\n    const r = diff > 1 ? \"r\" : diff < -1 ? \"l\" : \"\";\n    if (r) {\n        const l = r === \"r\" ? \"l\" : \"r\";\n        const rootClone = { ...target };\n        const oldRootRight = target[r];\n        target.from = oldRootRight.from;\n        target.to = oldRootRight.to;\n        target[r] = oldRootRight[r];\n        rootClone[r] = oldRootRight[l];\n        target[l] = rootClone;\n        rootClone.d = computeDepth(rootClone);\n    }\n    target.d = computeDepth(target);\n}\nfunction computeDepth({ r, l }) {\n    return (r ? (l ? Math.max(r.d, l.d) : r.d) : l ? l.d : 0) + 1;\n}\n\nconst observabilityMiddleware = {\n    stack: \"dbcore\",\n    level: 0,\n    create: (core) => {\n        const dbName = core.schema.name;\n        const FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);\n        return {\n            ...core,\n            table: (tableName) => {\n                const table = core.table(tableName);\n                const { schema } = table;\n                const { primaryKey } = schema;\n                const { extractKey, outbound } = primaryKey;\n                const tableClone = {\n                    ...table,\n                    mutate: (req) => {\n                        const trans = req.trans;\n                        const mutatedParts = trans.mutatedParts || (trans.mutatedParts = {});\n                        const getRangeSet = (indexName) => {\n                            const part = `idb://${dbName}/${tableName}/${indexName}`;\n                            return (mutatedParts[part] ||\n                                (mutatedParts[part] = new RangeSet()));\n                        };\n                        const pkRangeSet = getRangeSet(\"\");\n                        const delsRangeSet = getRangeSet(\":dels\");\n                        const { type } = req;\n                        let [keys, newObjs] = req.type === \"deleteRange\"\n                            ? [req.range]\n                            : req.type === \"delete\"\n                                ? [req.keys]\n                                : req.values.length < 50\n                                    ? [[], req.values]\n                                    : [];\n                        const oldCache = req.trans[\"_cache\"];\n                        return table.mutate(req).then((res) => {\n                            if (isArray(keys)) {\n                                if (type !== \"delete\")\n                                    keys = res.results;\n                                pkRangeSet.addKeys(keys);\n                                const oldObjs = getFromTransactionCache(keys, oldCache);\n                                if (!oldObjs && type !== \"add\") {\n                                    delsRangeSet.addKeys(keys);\n                                }\n                                if (oldObjs || newObjs) {\n                                    trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);\n                                }\n                            }\n                            else if (keys) {\n                                const range = { from: keys.lower, to: keys.upper };\n                                delsRangeSet.add(range);\n                                pkRangeSet.add(range);\n                            }\n                            else {\n                                pkRangeSet.add(FULL_RANGE);\n                                delsRangeSet.add(FULL_RANGE);\n                                schema.indexes.forEach(idx => getRangeSet(idx.name).add(FULL_RANGE));\n                            }\n                            return res;\n                        });\n                    },\n                };\n                const getRange = ({ query: { index, range }, }) => {\n                    var _a, _b;\n                    return [\n                        index,\n                        new RangeSet((_a = range.lower) !== null && _a !== void 0 ? _a : core.MIN_KEY, (_b = range.upper) !== null && _b !== void 0 ? _b : core.MAX_KEY),\n                    ];\n                };\n                const readSubscribers = {\n                    get: (req) => [primaryKey, new RangeSet(req.key)],\n                    getMany: (req) => [primaryKey, new RangeSet().addKeys(req.keys)],\n                    count: getRange,\n                    query: getRange,\n                    openCursor: getRange,\n                };\n                keys(readSubscribers).forEach(method => {\n                    tableClone[method] = function (req) {\n                        const { subscr } = PSD;\n                        if (subscr) {\n                            const getRangeSet = (indexName) => {\n                                const part = `idb://${dbName}/${tableName}/${indexName}`;\n                                return (subscr[part] ||\n                                    (subscr[part] = new RangeSet()));\n                            };\n                            const pkRangeSet = getRangeSet(\"\");\n                            const delsRangeSet = getRangeSet(\":dels\");\n                            const [queriedIndex, queriedRanges] = readSubscribers[method](req);\n                            getRangeSet(queriedIndex.name || \"\").add(queriedRanges);\n                            if (!queriedIndex.isPrimaryKey) {\n                                if (method === \"count\") {\n                                    delsRangeSet.add(FULL_RANGE);\n                                }\n                                else {\n                                    const keysPromise = method === \"query\" &&\n                                        outbound &&\n                                        req.values &&\n                                        table.query({\n                                            ...req,\n                                            values: false,\n                                        });\n                                    return table[method].apply(this, arguments).then((res) => {\n                                        if (method === \"query\") {\n                                            if (outbound && req.values) {\n                                                return keysPromise.then(({ result: resultingKeys }) => {\n                                                    pkRangeSet.addKeys(resultingKeys);\n                                                    return res;\n                                                });\n                                            }\n                                            const pKeys = req.values\n                                                ? res.result.map(extractKey)\n                                                : res.result;\n                                            if (req.values) {\n                                                pkRangeSet.addKeys(pKeys);\n                                            }\n                                            else {\n                                                delsRangeSet.addKeys(pKeys);\n                                            }\n                                        }\n                                        else if (method === \"openCursor\") {\n                                            const cursor = res;\n                                            const wantValues = req.values;\n                                            return (cursor &&\n                                                Object.create(cursor, {\n                                                    key: {\n                                                        get() {\n                                                            delsRangeSet.addKey(cursor.primaryKey);\n                                                            return cursor.key;\n                                                        },\n                                                    },\n                                                    primaryKey: {\n                                                        get() {\n                                                            const pkey = cursor.primaryKey;\n                                                            delsRangeSet.addKey(pkey);\n                                                            return pkey;\n                                                        },\n                                                    },\n                                                    value: {\n                                                        get() {\n                                                            wantValues && pkRangeSet.addKey(cursor.primaryKey);\n                                                            return cursor.value;\n                                                        },\n                                                    },\n                                                }));\n                                        }\n                                        return res;\n                                    });\n                                }\n                            }\n                        }\n                        return table[method].apply(this, arguments);\n                    };\n                });\n                return tableClone;\n            },\n        };\n    },\n};\nfunction trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {\n    function addAffectedIndex(ix) {\n        const rangeSet = getRangeSet(ix.name || \"\");\n        function extractKey(obj) {\n            return obj != null ? ix.extractKey(obj) : null;\n        }\n        const addKeyOrKeys = (key) => ix.multiEntry && isArray(key)\n            ? key.forEach(key => rangeSet.addKey(key))\n            : rangeSet.addKey(key);\n        (oldObjs || newObjs).forEach((_, i) => {\n            const oldKey = oldObjs && extractKey(oldObjs[i]);\n            const newKey = newObjs && extractKey(newObjs[i]);\n            if (cmp(oldKey, newKey) !== 0) {\n                if (oldKey != null)\n                    addKeyOrKeys(oldKey);\n                if (newKey != null)\n                    addKeyOrKeys(newKey);\n            }\n        });\n    }\n    schema.indexes.forEach(addAffectedIndex);\n}\n\nclass Dexie$1 {\n    constructor(name, options) {\n        this._middlewares = {};\n        this.verno = 0;\n        const deps = Dexie$1.dependencies;\n        this._options = options = {\n            addons: Dexie$1.addons,\n            autoOpen: true,\n            indexedDB: deps.indexedDB,\n            IDBKeyRange: deps.IDBKeyRange,\n            ...options\n        };\n        this._deps = {\n            indexedDB: options.indexedDB,\n            IDBKeyRange: options.IDBKeyRange\n        };\n        const { addons, } = options;\n        this._dbSchema = {};\n        this._versions = [];\n        this._storeNames = [];\n        this._allTables = {};\n        this.idbdb = null;\n        this._novip = this;\n        const state = {\n            dbOpenError: null,\n            isBeingOpened: false,\n            onReadyBeingFired: null,\n            openComplete: false,\n            dbReadyResolve: nop,\n            dbReadyPromise: null,\n            cancelOpen: nop,\n            openCanceller: null,\n            autoSchema: true\n        };\n        state.dbReadyPromise = new DexiePromise(resolve => {\n            state.dbReadyResolve = resolve;\n        });\n        state.openCanceller = new DexiePromise((_, reject) => {\n            state.cancelOpen = reject;\n        });\n        this._state = state;\n        this.name = name;\n        this.on = Events(this, \"populate\", \"blocked\", \"versionchange\", \"close\", { ready: [promisableChain, nop] });\n        this.on.ready.subscribe = override(this.on.ready.subscribe, subscribe => {\n            return (subscriber, bSticky) => {\n                Dexie$1.vip(() => {\n                    const state = this._state;\n                    if (state.openComplete) {\n                        if (!state.dbOpenError)\n                            DexiePromise.resolve().then(subscriber);\n                        if (bSticky)\n                            subscribe(subscriber);\n                    }\n                    else if (state.onReadyBeingFired) {\n                        state.onReadyBeingFired.push(subscriber);\n                        if (bSticky)\n                            subscribe(subscriber);\n                    }\n                    else {\n                        subscribe(subscriber);\n                        const db = this;\n                        if (!bSticky)\n                            subscribe(function unsubscribe() {\n                                db.on.ready.unsubscribe(subscriber);\n                                db.on.ready.unsubscribe(unsubscribe);\n                            });\n                    }\n                });\n            };\n        });\n        this.Collection = createCollectionConstructor(this);\n        this.Table = createTableConstructor(this);\n        this.Transaction = createTransactionConstructor(this);\n        this.Version = createVersionConstructor(this);\n        this.WhereClause = createWhereClauseConstructor(this);\n        this.on(\"versionchange\", ev => {\n            if (ev.newVersion > 0)\n                console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`);\n            else\n                console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`);\n            this.close();\n        });\n        this.on(\"blocked\", ev => {\n            if (!ev.newVersion || ev.newVersion < ev.oldVersion)\n                console.warn(`Dexie.delete('${this.name}') was blocked`);\n            else\n                console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${ev.oldVersion / 10}`);\n        });\n        this._maxKey = getMaxKey(options.IDBKeyRange);\n        this._createTransaction = (mode, storeNames, dbschema, parentTransaction) => new this.Transaction(mode, storeNames, dbschema, this._options.chromeTransactionDurability, parentTransaction);\n        this._fireOnBlocked = ev => {\n            this.on(\"blocked\").fire(ev);\n            connections\n                .filter(c => c.name === this.name && c !== this && !c._state.vcFired)\n                .map(c => c.on(\"versionchange\").fire(ev));\n        };\n        this.use(virtualIndexMiddleware);\n        this.use(hooksMiddleware);\n        this.use(observabilityMiddleware);\n        this.use(cacheExistingValuesMiddleware);\n        this.vip = Object.create(this, { _vip: { value: true } });\n        addons.forEach(addon => addon(this));\n    }\n    version(versionNumber) {\n        if (isNaN(versionNumber) || versionNumber < 0.1)\n            throw new exceptions.Type(`Given version is not a positive number`);\n        versionNumber = Math.round(versionNumber * 10) / 10;\n        if (this.idbdb || this._state.isBeingOpened)\n            throw new exceptions.Schema(\"Cannot add version when database is open\");\n        this.verno = Math.max(this.verno, versionNumber);\n        const versions = this._versions;\n        var versionInstance = versions.filter(v => v._cfg.version === versionNumber)[0];\n        if (versionInstance)\n            return versionInstance;\n        versionInstance = new this.Version(versionNumber);\n        versions.push(versionInstance);\n        versions.sort(lowerVersionFirst);\n        versionInstance.stores({});\n        this._state.autoSchema = false;\n        return versionInstance;\n    }\n    _whenReady(fn) {\n        return (this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip)) ? fn() : new DexiePromise((resolve, reject) => {\n            if (this._state.openComplete) {\n                return reject(new exceptions.DatabaseClosed(this._state.dbOpenError));\n            }\n            if (!this._state.isBeingOpened) {\n                if (!this._options.autoOpen) {\n                    reject(new exceptions.DatabaseClosed());\n                    return;\n                }\n                this.open().catch(nop);\n            }\n            this._state.dbReadyPromise.then(resolve, reject);\n        }).then(fn);\n    }\n    use({ stack, create, level, name }) {\n        if (name)\n            this.unuse({ stack, name });\n        const middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);\n        middlewares.push({ stack, create, level: level == null ? 10 : level, name });\n        middlewares.sort((a, b) => a.level - b.level);\n        return this;\n    }\n    unuse({ stack, name, create }) {\n        if (stack && this._middlewares[stack]) {\n            this._middlewares[stack] = this._middlewares[stack].filter(mw => create ? mw.create !== create :\n                name ? mw.name !== name :\n                    false);\n        }\n        return this;\n    }\n    open() {\n        return dexieOpen(this);\n    }\n    _close() {\n        const state = this._state;\n        const idx = connections.indexOf(this);\n        if (idx >= 0)\n            connections.splice(idx, 1);\n        if (this.idbdb) {\n            try {\n                this.idbdb.close();\n            }\n            catch (e) { }\n            this._novip.idbdb = null;\n        }\n        state.dbReadyPromise = new DexiePromise(resolve => {\n            state.dbReadyResolve = resolve;\n        });\n        state.openCanceller = new DexiePromise((_, reject) => {\n            state.cancelOpen = reject;\n        });\n    }\n    close() {\n        this._close();\n        const state = this._state;\n        this._options.autoOpen = false;\n        state.dbOpenError = new exceptions.DatabaseClosed();\n        if (state.isBeingOpened)\n            state.cancelOpen(state.dbOpenError);\n    }\n    delete() {\n        const hasArguments = arguments.length > 0;\n        const state = this._state;\n        return new DexiePromise((resolve, reject) => {\n            const doDelete = () => {\n                this.close();\n                var req = this._deps.indexedDB.deleteDatabase(this.name);\n                req.onsuccess = wrap(() => {\n                    _onDatabaseDeleted(this._deps, this.name);\n                    resolve();\n                });\n                req.onerror = eventRejectHandler(reject);\n                req.onblocked = this._fireOnBlocked;\n            };\n            if (hasArguments)\n                throw new exceptions.InvalidArgument(\"Arguments not allowed in db.delete()\");\n            if (state.isBeingOpened) {\n                state.dbReadyPromise.then(doDelete);\n            }\n            else {\n                doDelete();\n            }\n        });\n    }\n    backendDB() {\n        return this.idbdb;\n    }\n    isOpen() {\n        return this.idbdb !== null;\n    }\n    hasBeenClosed() {\n        const dbOpenError = this._state.dbOpenError;\n        return dbOpenError && (dbOpenError.name === 'DatabaseClosed');\n    }\n    hasFailed() {\n        return this._state.dbOpenError !== null;\n    }\n    dynamicallyOpened() {\n        return this._state.autoSchema;\n    }\n    get tables() {\n        return keys(this._allTables).map(name => this._allTables[name]);\n    }\n    transaction() {\n        const args = extractTransactionArgs.apply(this, arguments);\n        return this._transaction.apply(this, args);\n    }\n    _transaction(mode, tables, scopeFunc) {\n        let parentTransaction = PSD.trans;\n        if (!parentTransaction || parentTransaction.db !== this || mode.indexOf('!') !== -1)\n            parentTransaction = null;\n        const onlyIfCompatible = mode.indexOf('?') !== -1;\n        mode = mode.replace('!', '').replace('?', '');\n        let idbMode, storeNames;\n        try {\n            storeNames = tables.map(table => {\n                var storeName = table instanceof this.Table ? table.name : table;\n                if (typeof storeName !== 'string')\n                    throw new TypeError(\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\");\n                return storeName;\n            });\n            if (mode == \"r\" || mode === READONLY)\n                idbMode = READONLY;\n            else if (mode == \"rw\" || mode == READWRITE)\n                idbMode = READWRITE;\n            else\n                throw new exceptions.InvalidArgument(\"Invalid transaction mode: \" + mode);\n            if (parentTransaction) {\n                if (parentTransaction.mode === READONLY && idbMode === READWRITE) {\n                    if (onlyIfCompatible) {\n                        parentTransaction = null;\n                    }\n                    else\n                        throw new exceptions.SubTransaction(\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\");\n                }\n                if (parentTransaction) {\n                    storeNames.forEach(storeName => {\n                        if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {\n                            if (onlyIfCompatible) {\n                                parentTransaction = null;\n                            }\n                            else\n                                throw new exceptions.SubTransaction(\"Table \" + storeName +\n                                    \" not included in parent transaction.\");\n                        }\n                    });\n                }\n                if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {\n                    parentTransaction = null;\n                }\n            }\n        }\n        catch (e) {\n            return parentTransaction ?\n                parentTransaction._promise(null, (_, reject) => { reject(e); }) :\n                rejection(e);\n        }\n        const enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);\n        return (parentTransaction ?\n            parentTransaction._promise(idbMode, enterTransaction, \"lock\") :\n            PSD.trans ?\n                usePSD(PSD.transless, () => this._whenReady(enterTransaction)) :\n                this._whenReady(enterTransaction));\n    }\n    table(tableName) {\n        if (!hasOwn(this._allTables, tableName)) {\n            throw new exceptions.InvalidTable(`Table ${tableName} does not exist`);\n        }\n        return this._allTables[tableName];\n    }\n}\n\nconst symbolObservable = typeof Symbol !== \"undefined\" && \"observable\" in Symbol\n    ? Symbol.observable\n    : \"@@observable\";\nclass Observable {\n    constructor(subscribe) {\n        this._subscribe = subscribe;\n    }\n    subscribe(x, error, complete) {\n        return this._subscribe(!x || typeof x === \"function\" ? { next: x, error, complete } : x);\n    }\n    [symbolObservable]() {\n        return this;\n    }\n}\n\nfunction extendObservabilitySet(target, newSet) {\n    keys(newSet).forEach(part => {\n        const rangeSet = target[part] || (target[part] = new RangeSet());\n        mergeRanges(rangeSet, newSet[part]);\n    });\n    return target;\n}\n\nfunction liveQuery(querier) {\n    return new Observable((observer) => {\n        const scopeFuncIsAsync = isAsyncFunction(querier);\n        function execute(subscr) {\n            if (scopeFuncIsAsync) {\n                incrementExpectedAwaits();\n            }\n            const exec = () => newScope(querier, { subscr, trans: null });\n            const rv = PSD.trans\n                ?\n                    usePSD(PSD.transless, exec)\n                : exec();\n            if (scopeFuncIsAsync) {\n                rv.then(decrementExpectedAwaits, decrementExpectedAwaits);\n            }\n            return rv;\n        }\n        let closed = false;\n        let accumMuts = {};\n        let currentObs = {};\n        const subscription = {\n            get closed() {\n                return closed;\n            },\n            unsubscribe: () => {\n                closed = true;\n                globalEvents.storagemutated.unsubscribe(mutationListener);\n            },\n        };\n        observer.start && observer.start(subscription);\n        let querying = false, startedListening = false;\n        function shouldNotify() {\n            return keys(currentObs).some((key) => accumMuts[key] && rangesOverlap(accumMuts[key], currentObs[key]));\n        }\n        const mutationListener = (parts) => {\n            extendObservabilitySet(accumMuts, parts);\n            if (shouldNotify()) {\n                doQuery();\n            }\n        };\n        const doQuery = () => {\n            if (querying || closed)\n                return;\n            accumMuts = {};\n            const subscr = {};\n            const ret = execute(subscr);\n            if (!startedListening) {\n                globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);\n                startedListening = true;\n            }\n            querying = true;\n            Promise.resolve(ret).then((result) => {\n                querying = false;\n                if (closed)\n                    return;\n                if (shouldNotify()) {\n                    doQuery();\n                }\n                else {\n                    accumMuts = {};\n                    currentObs = subscr;\n                    observer.next && observer.next(result);\n                }\n            }, (err) => {\n                querying = false;\n                observer.error && observer.error(err);\n                subscription.unsubscribe();\n            });\n        };\n        doQuery();\n        return subscription;\n    });\n}\n\nlet domDeps;\ntry {\n    domDeps = {\n        indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,\n        IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange\n    };\n}\ncatch (e) {\n    domDeps = { indexedDB: null, IDBKeyRange: null };\n}\n\nconst Dexie = Dexie$1;\nprops(Dexie, {\n    ...fullNameExceptions,\n    delete(databaseName) {\n        const db = new Dexie(databaseName, { addons: [] });\n        return db.delete();\n    },\n    exists(name) {\n        return new Dexie(name, { addons: [] }).open().then(db => {\n            db.close();\n            return true;\n        }).catch('NoSuchDatabaseError', () => false);\n    },\n    getDatabaseNames(cb) {\n        try {\n            return getDatabaseNames(Dexie.dependencies).then(cb);\n        }\n        catch (_a) {\n            return rejection(new exceptions.MissingAPI());\n        }\n    },\n    defineClass() {\n        function Class(content) {\n            extend(this, content);\n        }\n        return Class;\n    },\n    ignoreTransaction(scopeFunc) {\n        return PSD.trans ?\n            usePSD(PSD.transless, scopeFunc) :\n            scopeFunc();\n    },\n    vip,\n    async: function (generatorFn) {\n        return function () {\n            try {\n                var rv = awaitIterator(generatorFn.apply(this, arguments));\n                if (!rv || typeof rv.then !== 'function')\n                    return DexiePromise.resolve(rv);\n                return rv;\n            }\n            catch (e) {\n                return rejection(e);\n            }\n        };\n    },\n    spawn: function (generatorFn, args, thiz) {\n        try {\n            var rv = awaitIterator(generatorFn.apply(thiz, args || []));\n            if (!rv || typeof rv.then !== 'function')\n                return DexiePromise.resolve(rv);\n            return rv;\n        }\n        catch (e) {\n            return rejection(e);\n        }\n    },\n    currentTransaction: {\n        get: () => PSD.trans || null\n    },\n    waitFor: function (promiseOrFunction, optionalTimeout) {\n        const promise = DexiePromise.resolve(typeof promiseOrFunction === 'function' ?\n            Dexie.ignoreTransaction(promiseOrFunction) :\n            promiseOrFunction)\n            .timeout(optionalTimeout || 60000);\n        return PSD.trans ?\n            PSD.trans.waitFor(promise) :\n            promise;\n    },\n    Promise: DexiePromise,\n    debug: {\n        get: () => debug,\n        set: value => {\n            setDebug(value, value === 'dexie' ? () => true : dexieStackFrameFilter);\n        }\n    },\n    derive: derive,\n    extend: extend,\n    props: props,\n    override: override,\n    Events: Events,\n    on: globalEvents,\n    liveQuery,\n    extendObservabilitySet,\n    getByKeyPath: getByKeyPath,\n    setByKeyPath: setByKeyPath,\n    delByKeyPath: delByKeyPath,\n    shallowClone: shallowClone,\n    deepClone: deepClone,\n    getObjectDiff: getObjectDiff,\n    cmp,\n    asap: asap$1,\n    minKey: minKey,\n    addons: [],\n    connections: connections,\n    errnames: errnames,\n    dependencies: domDeps,\n    semVer: DEXIE_VERSION,\n    version: DEXIE_VERSION.split('.')\n        .map(n => parseInt(n))\n        .reduce((p, c, i) => p + (c / Math.pow(10, i * 2))),\n});\nDexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);\n\nif (typeof dispatchEvent !== 'undefined' && typeof addEventListener !== 'undefined') {\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, updatedParts => {\n        if (!propagatingLocally) {\n            let event;\n            if (isIEOrEdge) {\n                event = document.createEvent('CustomEvent');\n                event.initCustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, true, true, updatedParts);\n            }\n            else {\n                event = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {\n                    detail: updatedParts\n                });\n            }\n            propagatingLocally = true;\n            dispatchEvent(event);\n            propagatingLocally = false;\n        }\n    });\n    addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, ({ detail }) => {\n        if (!propagatingLocally) {\n            propagateLocally(detail);\n        }\n    });\n}\nfunction propagateLocally(updateParts) {\n    let wasMe = propagatingLocally;\n    try {\n        propagatingLocally = true;\n        globalEvents.storagemutated.fire(updateParts);\n    }\n    finally {\n        propagatingLocally = wasMe;\n    }\n}\nlet propagatingLocally = false;\n\nif (typeof BroadcastChannel !== 'undefined') {\n    const bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {\n        if (!propagatingLocally) {\n            bc.postMessage(changedParts);\n        }\n    });\n    bc.onmessage = (ev) => {\n        if (ev.data)\n            propagateLocally(ev.data);\n    };\n}\nelse if (typeof self !== 'undefined' && typeof navigator !== 'undefined') {\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {\n        try {\n            if (!propagatingLocally) {\n                if (typeof localStorage !== 'undefined') {\n                    localStorage.setItem(STORAGE_MUTATED_DOM_EVENT_NAME, JSON.stringify({\n                        trig: Math.random(),\n                        changedParts,\n                    }));\n                }\n                if (typeof self['clients'] === 'object') {\n                    [...self['clients'].matchAll({ includeUncontrolled: true })].forEach((client) => client.postMessage({\n                        type: STORAGE_MUTATED_DOM_EVENT_NAME,\n                        changedParts,\n                    }));\n                }\n            }\n        }\n        catch (_a) { }\n    });\n    addEventListener('storage', (ev) => {\n        if (ev.key === STORAGE_MUTATED_DOM_EVENT_NAME) {\n            const data = JSON.parse(ev.newValue);\n            if (data)\n                propagateLocally(data.changedParts);\n        }\n    });\n    const swContainer = self.document && navigator.serviceWorker;\n    if (swContainer) {\n        swContainer.addEventListener('message', propagateMessageLocally);\n    }\n}\nfunction propagateMessageLocally({ data }) {\n    if (data && data.type === STORAGE_MUTATED_DOM_EVENT_NAME) {\n        propagateLocally(data.changedParts);\n    }\n}\n\nDexiePromise.rejectionMapper = mapError;\nsetDebug(debug, dexieStackFrameFilter);\n\nexport { Dexie$1 as Dexie, RangeSet, Dexie$1 as default, liveQuery, mergeRanges, rangesOverlap };\n//# sourceMappingURL=dexie.mjs.map\n","import root from './_root.js';\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\nexport default now;\n","import isObject from './isObject.js';\nimport now from './now.js';\nimport toNumber from './toNumber.js';\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nexport default debounce;\n","import baseFindIndex from './_baseFindIndex.js';\nimport baseIteratee from './_baseIteratee.js';\nimport toInteger from './toInteger.js';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * This method is like `_.find` except that it returns the index of the first\n * element `predicate` returns truthy for instead of the element itself.\n *\n * @static\n * @memberOf _\n * @since 1.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': false },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': true }\n * ];\n *\n * _.findIndex(users, function(o) { return o.user == 'barney'; });\n * // => 0\n *\n * // The `_.matches` iteratee shorthand.\n * _.findIndex(users, { 'user': 'fred', 'active': false });\n * // => 1\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.findIndex(users, ['active', false]);\n * // => 0\n *\n * // The `_.property` iteratee shorthand.\n * _.findIndex(users, 'active');\n * // => 2\n */\nfunction findIndex(array, predicate, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\n  if (index < 0) {\n    index = nativeMax(length + index, 0);\n  }\n  return baseFindIndex(array, baseIteratee(predicate, 3), index);\n}\n\nexport default findIndex;\n","import createFind from './_createFind.js';\nimport findIndex from './findIndex.js';\n\n/**\n * Iterates over elements of `collection`, returning the first element\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {*} Returns the matched element, else `undefined`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'age': 36, 'active': true },\n *   { 'user': 'fred',    'age': 40, 'active': false },\n *   { 'user': 'pebbles', 'age': 1,  'active': true }\n * ];\n *\n * _.find(users, function(o) { return o.age < 40; });\n * // => object for 'barney'\n *\n * // The `_.matches` iteratee shorthand.\n * _.find(users, { 'age': 1, 'active': true });\n * // => object for 'pebbles'\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.find(users, ['active', false]);\n * // => object for 'fred'\n *\n * // The `_.property` iteratee shorthand.\n * _.find(users, 'active');\n * // => object for 'barney'\n */\nvar find = createFind(findIndex);\n\nexport default find;\n","import baseIteratee from './_baseIteratee.js';\nimport isArrayLike from './isArrayLike.js';\nimport keys from './keys.js';\n\n/**\n * Creates a `_.find` or `_.findLast` function.\n *\n * @private\n * @param {Function} findIndexFunc The function to find the collection index.\n * @returns {Function} Returns the new find function.\n */\nfunction createFind(findIndexFunc) {\n  return function(collection, predicate, fromIndex) {\n    var iterable = Object(collection);\n    if (!isArrayLike(collection)) {\n      var iteratee = baseIteratee(predicate, 3);\n      collection = keys(collection);\n      predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n    }\n    var index = findIndexFunc(collection, predicate, fromIndex);\n    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n  };\n}\n\nexport default createFind;\n","/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nexport default baseFindIndex;\n","import root from './_root.js';\nimport toInteger from './toInteger.js';\nimport toNumber from './toNumber.js';\nimport toString from './toString.js';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsFinite = root.isFinite,\n    nativeMin = Math.min;\n\n/**\n * Creates a function like `_.round`.\n *\n * @private\n * @param {string} methodName The name of the `Math` method to use when rounding.\n * @returns {Function} Returns the new round function.\n */\nfunction createRound(methodName) {\n  var func = Math[methodName];\n  return function(number, precision) {\n    number = toNumber(number);\n    precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);\n    if (precision && nativeIsFinite(number)) {\n      // Shift with exponential notation to avoid floating-point issues.\n      // See [MDN](https://mdn.io/round#Examples) for more details.\n      var pair = (toString(number) + 'e').split('e'),\n          value = func(pair[0] + 'e' + (+pair[1] + precision));\n\n      pair = (toString(value) + 'e').split('e');\n      return +(pair[0] + 'e' + (+pair[1] - precision));\n    }\n    return func(number);\n  };\n}\n\nexport default createRound;\n","import createRound from './_createRound.js';\n\n/**\n * Computes `number` rounded to `precision`.\n *\n * @static\n * @memberOf _\n * @since 3.10.0\n * @category Math\n * @param {number} number The number to round.\n * @param {number} [precision=0] The precision to round to.\n * @returns {number} Returns the rounded number.\n * @example\n *\n * _.round(4.006);\n * // => 4\n *\n * _.round(4.006, 2);\n * // => 4.01\n *\n * _.round(4060, -2);\n * // => 4100\n */\nvar round = createRound('round');\n\nexport default round;\n","import toNumber from './toNumber.js';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e+308;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\nexport default toFinite;\n","import toFinite from './toFinite.js';\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\nexport default toInteger;\n","/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\nexport default trimmedEndIndex;\n","import trimmedEndIndex from './_trimmedEndIndex.js';\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\nexport default baseTrim;\n","import baseTrim from './_baseTrim.js';\nimport isObject from './isObject.js';\nimport isSymbol from './isSymbol.js';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nexport default toNumber;\n"],"names":["exports","dexie","React","_interopDefaultLegacy","e","React__default","useObservable","observableFactory","arg2","arg3","deps","defaultResult","monitor","useRef","hasResult","result","error","_a","useReducer","x","triggerUpdate","observable","useMemo","subscribe","TypeError","current","getValue","subscription","val","unsubscribe","useDebugValue","useEffect","err","bind","useLiveQuery","querier","liveQuery","usePermissions","firstArg","table","obj","db","arguments","length","Dexie","Error","cloud","permissions","realmId","owner","Object","defineProperty","value","factory","_global","globalThis","self","window","global","keys","isArray","Array","extend","extension","forEach","key","Promise","getProto","getPrototypeOf","_hasOwn","hasOwnProperty","hasOwn","prop","call","props","proto","Reflect","ownKeys","setProp","functionOrGetSet","options","get","set","configurable","writable","derive","Child","from","Parent","prototype","create","getOwnPropertyDescriptor","getPropertyDescriptor","_slice","slice","args","start","end","override","origFunc","overridedFactory","assert","b","asap$1","fn","setImmediate","setTimeout","arrayToObject","array","extractor","reduce","item","i","nameAndValue","getByKeyPath","keyPath","rv","l","push","period","indexOf","innerObj","substr","undefined","setByKeyPath","isFrozen","currentKeyPath","remainingKeyPath","isNaN","parseInt","splice","shallowClone","m","concat","flatten","a","apply","intrinsicTypeNames","split","map","num","t","filter","intrinsicTypes","circularRefs","deepClone","any","WeakMap","innerDeepClone","constructor","toString","toStringTag","o","iteratorSymbol","Symbol","iterator","getIteratorOf","NO_CHAR_ARRAY","getArrayOf","arrayLike","it","this","next","done","isAsyncFunction","debug","location","test","href","setDebug","libraryFilter","NEEDS_THROW_FOR_STACK","stack","getErrorWithStack","prettyStack","exception","numIgnoredFrames","name","message","frame","join","idbDomErrorNames","errorList","defaultTexts","VersionChanged","DatabaseClosed","Abort","TransactionInactive","MissingAPI","DexieError","msg","_e","getMultiErrorMessage","failures","v","s","ModifyError","successCount","failedKeys","BulkError","pos","failuresByPos","_stack","errnames","BaseException","exceptions","fullName","msgOrInner","inner","Syntax","SyntaxError","Type","Range","RangeError","exceptionMap","fullNameExceptions","nop","mirror","pureFunctionChain","f1","f2","callBoth","on1","on2","hookCreatingChain","res","onsuccess","onerror","res2","hookDeletingChain","hookUpdatingChain","modifications","reverseStoppableEventChain","promisableChain","then","thiz","INTERNAL","resolvedNativePromise","nativePromiseProto","resolvedGlobalPromise","globalP","resolve","crypto","subtle","nativeP","digest","Uint8Array","nativePromiseThen","NativePromise","patchGlobalPromise","stack_being_generated","schedulePhysicalTick","physicalTick","MutationObserver","hiddenDiv","document","createElement","observe","attributes","setAttribute","asap","callback","microtickQueue","needsNewPhysicalTick","isOutsideMicroTick","unhandledErrors","rejectingErrors","currentFulfiller","rejectionMapper","globalPSD","id","ref","unhandleds","onunhandled","globalError","pgp","env","finalize","uh","PSD","numScheduledCalls","tickFinalizers","DexiePromise","_listeners","onuncatched","_lib","psd","_PSD","_stackHolder","_prev","_numPrev","_state","_value","handleRejection","executePromiseTask","thenProp","microTaskId","totalEchoes","onFulfilled","onRejected","possibleAwait","cleanup","decrementExpectedAwaits","reject","propagateToListener","Listener","nativeAwaitCompatibleWrap","linkToPreviousPromise","zone","promise","shouldExecuteTick","beginMicroTickScope","_then","propagateAllListeners","endMicroTickScope","ex","reason","_promise","origProp","tryCatch","some","p","addPossiblyUnhandledError","listeners","len","finalizePhysicalTick","listener","cb","callListener","ret","markErrorAsHandled","getStack","stacks","limit","errorName","failure","prev","numPrev","wasRootExec","callbacks","unhandledErrs","finalizers","PromiseReject","wrap","errorCatcher","outerScope","switchToZone","catch","type","handler","finally","onFinally","timeout","ms","Infinity","handle","Timeout","clearTimeout","snapShot","all","values","onPossibleParallellAsync","remaining","race","newPSD","newScope","usePSD","scheduler","follow","zoneProps","finalizer","run_at_end_of_this_or_next_physical_tick","allSettled","possiblePromises","results","status","AggregateError","task","awaits","echoes","taskCounter","zoneStack","zoneEchoes","zone_id_counter","a1","a2","parent","globalEnv","PromiseProp","nthen","getPatchedPromiseThen","gthen","incrementExpectedAwaits","possiblePromise","rejection","zoneEnterEcho","targetZone","zoneLeaveEcho","pop","bEnteringZone","currentZone","enqueueNativeMicroTask","GlobalPromise","targetEnv","a3","job","outerZone","origThen","onResolved","UNHANDLEDREJECTION","event","eventData","createEvent","initEvent","CustomEvent","detail","dispatchEvent","PromiseRejectionEvent","onunhandledrejection","_","defaultPrevented","console","warn","tempTransaction","mode","storeNames","idbdb","openComplete","letThrough","_vip","trans","_createTransaction","_dbSchema","_completion","dbOpenError","isBeingOpened","_options","autoOpen","open","dbReadyPromise","DEXIE_VERSION","maxString","String","fromCharCode","minKey","INVALID_KEY_ARGUMENT","STRING_EXPECTED","connections","isIEOrEdge","navigator","userAgent","hasIEDeleteObjectStoreBug","hangsOnDeleteLargeKeyRange","dexieStackFrameFilter","DBNAMES_DB","READONLY","READWRITE","combine","filter1","filter2","AnyRange","lower","lowerOpen","upper","upperOpen","workaroundForUndefinedPrimKey","Table","_trans","writeLocked","_tx","tableName","checkTableInTransaction","schema","NotFound","idbtrans","transless","keyOrCrit","where","first","core","hook","reading","fire","indexOrCrit","WhereClause","keyPaths","equals","compoundIndex","indexes","primKey","ix","compound","every","_maxKey","kp","JSON","stringify","idxByName","idb","_deps","indexedDB","cmp","idx","filterFunction","prevIndex","prevFilterFn","index","multi","toCollection","and","count","thenShortcut","offset","numRows","each","toArray","Collection","orderBy","reverse","mapToClass","mappedClass","readHook","defineClass","content","add","auto","objToAdd","mutate","numFailures","lastResult","update","keyOrObject","modify","InvalidArgument","put","delete","clear","range","bulkGet","getMany","bulkAdd","objects","keysOrOptions","wantResults","allKeys","numObjects","objectsToAdd","bulkPut","objectsToPut","bulkDelete","numKeys","Events","ctx","evs","eventName","subscriber","addEventType","chainFunction","defaultFunction","addConfiguredEvents","context","subscribers","cfg","makeClassConstructor","isPlainKeyRange","ignoreLimitFilter","algorithm","or","justLimit","replayFilter","addFilter","addReplayFilter","isLimitFilter","curr","getIndexOrStore","coreSchema","isPrimKey","primaryKey","getIndexByKeyPath","Schema","openCursor","coreTable","keysOnly","dir","unique","query","iter","coreTrans","union","cursor","advance","stop","fail","_iterate","iterate","valueMapper","cursorPromise","wrappedFn","c","continue","advancer","ta","tb","NaN","al","bl","compareUint8Arrays","getUint8Array","compareArrays","ArrayBuffer","isView","tsTag","buffer","byteOffset","byteLength","_read","_ctx","_write","_addAlgorithm","clone","raw","Math","min","sortBy","parts","lastPart","lastIndex","getval","order","sorter","aVal","bVal","sort","offsetLeft","rowsLeft","until","bIncludeStopEntry","last","isMatch","indexName","_ondirectionchange","desc","eachKey","eachUniqueKey","eachPrimaryKey","primaryKeys","uniqueKeys","firstKey","lastKey","distinct","strKey","found","changes","modifyer","anythingModified","outbound","extractKey","modifyChunkSize","totalFailures","applyMutateResult","expectedCount","nextChunk","cache","addValues","putValues","putKeys","deleteKeys","origValue","criteria","deleteCallback","changeSpec","coreRange","simpleCompare","simpleCompareReverse","collectionOrWhereClause","T","collection","emptyCollection","whereClause","rangeEqual","nextCasing","lowerKey","upperNeedle","lowerNeedle","llp","lwrKeyChar","addIgnoreCaseAlgorithm","match","needles","suffix","compare","upperNeedles","lowerNeedles","direction","nextKeySuffix","needlesLen","initDirection","toUpperCase","toLowerCase","upperFactory","lowerFactory","needleBounds","needle","nb","createRange","firstPossibleNeedle","lowestPossibleCasing","casing","between","includeLower","includeUpper","_cmp","above","aboveOrEqual","below","belowOrEqual","startsWith","str","startsWithIgnoreCase","equalsIgnoreCase","anyOfIgnoreCase","startsWithAnyOfIgnoreCase","n","anyOf","_ascending","_descending","notEqual","inAnyRange","includeLowers","includeUppers","noneOf","ranges","ascending","descending","_min","max","_max","sortDirection","rangeSorter","newRange","rangePos","keyIsBeyondCurrentEntry","keyIsBeforeCurrentEntry","checkKey","keyWithinCurrentRange","startsWithAnyOf","eventRejectHandler","preventDefault","target","stopPropagation","DEXIE_STORAGE_MUTATED_EVENT_NAME","STORAGE_MUTATED_DOM_EVENT_NAME","globalEvents","Transaction","_lock","_reculock","lockOwnerFor","_unlock","_blockedFuncs","_locked","fnAndPSD","shift","OpenFailed","active","transaction","durability","chromeTransactionDurability","ev","_reject","onabort","on","oncomplete","_resolve","storagemutated","bWriteLock","ReadOnly","_root","waitFor","promiseLike","root","_waitingFor","_waitingQueue","store","objectStore","spin","_spinCount","currentWaitPromise","abort","memoizedTables","_memoizedTables","tableSchema","transactionBoundTable","createIndexSpec","src","nameFromKeyPath","createTableSchema","getMaxKey","IdbKeyRange","only","getKeyExtractor","getSinglePathKeyExtractor","arrayify","_id_counter","getKeyPathAlias","generateMiddlewareStacks","_novip","tmpTrans","middlewares","IDBKeyRange","dbcore","stackImpl","down","createMiddlewareStack","makeIDBKeyRange","upperBound","lowerBound","bound","hasGetAll","tables","objectStoreNames","autoIncrement","indexByKeyPath","isPrimaryKey","indexNames","multiEntry","extractSchema","isAddOrPut","req","reqs","errorHandler","args1","args2","keyCount","callbackCount","successHandler","_pos","request","nonInfinitLimit","source","idbKeyRange","getAll","getAllKeys","openKeyCursor","___id","_cursorContinue","_cursorContinuePrimaryKey","continuePrimaryKey","_cursorAdvance","doThrowCursorIsStopped","gotOne","iterationPromise","resolveIteration","rejectIteration","guardedCallback","createDbCoreTable","tableMap","MIN_KEY","MAX_KEY","createDBCore","createMiddlewareStacks","_middlewares","tbl","setApiOnPlace","objs","tableNames","dbschema","propDesc","enumerable","removeTablesApi","lowerVersionFirst","_cfg","version","getSchemaDiff","oldSchema","newSchema","diff","del","change","oldDef","newDef","def","recreate","oldIndexes","newIndexes","idxName","oldIdx","newIdx","createTable","createObjectStore","addIndex","createIndex","buildGlobalSchema","globalSchema","storeName","j","idbindex","adjustToExistingIndexNames","_hasGetAll","dexieName","indexSpec","WorkerGlobalScope","Version","_parseStoresSpec","stores","outSchema","indexNum","trim","replace","storesSource","versions","_versions","storesSpec","_allTables","_storeNames","upgrade","upgradeFunction","contentUpgrade","getDbNamesTable","dbNamesDB","Dexie$1","addons","dbnames","hasDatabasesNative","databases","vip","idbReady","intervalId","userAgentData","tryIdb","setInterval","clearInterval","dexieOpen","state","openCanceller","throwIfCancelled","resolveDbReady","dbReadyResolve","upgradeTransaction","wasCreated","dbName","autoSchema","round","verno","onblocked","_fireOnBlocked","onupgradeneeded","allowEmptyDB","close","delreq","deleteDatabase","NoSuchDatabase","oldVer","oldVersion","pow","idbUpgradeTrans","rejectTransaction","populate","queue","anyContentUpgraderHasRun","tuple","Upgrade","deleteIndex","upgradeSchema","contentUpgradeIsAsync","returnValue","promiseFollowed","decrementor","deleteObjectStore","deleteRemovedTables","runQueue","contains","updateTablesAndIndexes","runUpgraders","readGlobalSchema","ch","verifyInstalledSchema","onversionchange","vcFired","onclose","_onDatabaseCreated","onReadyBeingFired","ready","fireRemainders","remainders","_close","awaitIterator","callNext","onSuccess","step","onError","throw","getNext","extractTransactionArgs","_tableArgs_","scopeFunc","enterTransactionScope","parentTransaction","scopeFuncIsAsync","PrematureCommit","pad","virtualIndexMiddleware","level","indexLookup","allVirtualIndexes","addVirtualIndexes","keyTail","lowLevelIndex","keyPathAlias","indexList","keyLength","isVirtual","virtualIndex","translateRequest","virtualCursor","createVirtualCursor","getObjectDiff","prfx","ap","bp","apTypeName","hooksMiddleware","downCore","downTable","tableMiddleware","dxTrans","deleting","creating","updating","addPutOrDelete","deleteNextChunk","deleteRange","getEffectiveKeys","effectiveKeys","getExistingValues","existingValues","contexts","existingValue","generatedPrimaryKey","objectDiff","additionalChanges","requestedValue","getFromTransactionCache","cacheExistingValuesMiddleware","cachedResult","isEmptyRange","node","RangeSet","fromOrTree","to","d","addRange","left","right","r","rebalance","rightWasCutOff","mergeRanges","newSet","_addRangeSet","rangesOverlap","rangeSet1","rangeSet2","i1","getRangeSetIterator","nextResult1","i2","nextResult2","keyProvided","up","_b","rootClone","oldRootRight","computeDepth","rangeSet","addKey","addKeys","observabilityMiddleware","FULL_RANGE","tableClone","mutatedParts","getRangeSet","part","pkRangeSet","delsRangeSet","newObjs","oldCache","oldObjs","addKeyOrKeys","oldKey","newKey","trackAffectedIndexes","getRange","readSubscribers","method","subscr","queriedIndex","queriedRanges","keysPromise","resultingKeys","pKeys","wantValues","pkey","dependencies","cancelOpen","bSticky","keyRangeGenerator","keyRange","whereCtx","readingHook","createTableConstructor","complete","wasActive","createTransactionConstructor","versionNumber","createVersionConstructor","orCollection","_IDBKeyRange","createWhereClauseConstructor","newVersion","use","addon","versionInstance","_whenReady","unuse","mw","hasArguments","doDelete","_onDatabaseDeleted","backendDB","isOpen","hasBeenClosed","hasFailed","dynamicallyOpened","_transaction","onlyIfCompatible","idbMode","SubTransaction","enterTransaction","InvalidTable","symbolObservable","Observable","_subscribe","extendObservabilitySet","observer","closed","accumMuts","currentObs","mutationListener","querying","startedListening","shouldNotify","doQuery","exec","execute","domDeps","mozIndexedDB","webkitIndexedDB","msIndexedDB","webkitIDBKeyRange","propagateLocally","updateParts","wasMe","propagatingLocally","databaseName","exists","getDatabaseNames","infos","info","ignoreTransaction","async","generatorFn","spawn","currentTransaction","promiseOrFunction","optionalTimeout","delByKeyPath","semVer","maxKey","addEventListener","updatedParts","initCustomEvent","BroadcastChannel","bc","changedParts","postMessage","onmessage","data","localStorage","setItem","trig","random","matchAll","includeUncontrolled","client","parse","newValue","swContainer","serviceWorker","domError","nativeMax","nativeMin","func","wait","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","invokeFunc","time","thisArg","leadingEdge","timerExpired","shouldInvoke","timeSinceLastCall","trailingEdge","timeWaiting","remainingWait","debounced","isInvoking","toNumber","isObject","cancel","flush","findIndexFunc","predicate","fromIndex","toInteger","fromRight","iterable","isArrayLike","iteratee","nativeIsFinite","number","precision","pair","remainder","reWhitespace","reTrimStart","string","charAt","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","isSymbol","other","valueOf","isBinary"],"sourceRoot":""}